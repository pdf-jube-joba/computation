## スコープと局所変数
ここからは、仮想レジスタをあまり意識しないで使いたい。
特に、load/store はあまり書きたくないので、
下の flow_ir に落とし込めるようにしつつ、 load/store は使わない方針で行く。
正直、これだけやると、仮想レジスタの場合と何が違うのかがわからない。
load/store が消えたのと、値の共有がされなくなっただけ。
とりあえず書くことにすると、こんな感じ。
（普通に、 load/store が消えただけ。）
```
<clabel>  ::= "@" <string>
<dlabel>  ::= "@." <string>
<lvar>    ::= "$" <string>

<atom> = <dlabel> | <lvar>

<local>   ::= "local" <lvar>+ ";"
<stmt>    ::= (
  <var> ":=" <var> <op> <atom>
    | "Nop" | "Halt" | "Readpc" <var>
  ) ";"

<cond>    ::= <atom> "<" <atom> | <atom> "==" <atom>
<jump>    ::= <var> | <clabel>
<cont>    ::= 
  "goto" <jump> ";"
  | "if" <cond> "then" <jump> ";" <cont>
<block>   ::= <clabel> "{" <local>? <stmt>* <cont> "}"
<static>  ::= <dlabel> <imm> ";"

<program> ::= <static>* <block>*
```
実は、値の共有がされなくなったのはかなりまずい。
どうしてまずいかを考えると、ブロック間での計算結果の共有に、 static を使う必要が出てきてめんどくさい。（できないわけではない。）
これの解決方法として次のものがある（これは実質的には同じことをやっている。）
- ブロックに引数を持たせる
- 各ブロックで共有する用に専用のスタック領域を用意する

ここでは別の動機もあるので、ブロックの nest と局所変数を許すことでこれを解決する。
ざっくりいうと、「このブロックのまとまりでは共通してこの変数が使える」ことを宣言できるようになる。
別の動機：

```
<stmt>    ::= (
  <var> ":=" <var> <op> <atom>
    | "Nop" | "Halt" | "Readpc" <var>
    | "block" <block>
  ) ";"
<block>   ::= <clabel> "{" <local>? <stmt>* <cont> "}"
```
局所変数はジャンプ時にどうなるかというのがめんどくさい。
例えば、親が同じブロックであれば、自分のところで確保した局所変数は全て扱えなくした状態でそこに飛べばいい。
同じように考えると、親の親を共有している...とかはいける。
ブログラム全体はブロックの入れ子で木構造をなしているので、ジャンプに対しては、
祖先からフラットに進んだところだけジャンプができるとしておく。

正直これだけあれば結構なことができるので、ここで終わってもいいが、これだとあとで困る。
局所変数は領域でとって、そこに index でアクセスしたほうが嬉しい。

```
<local>   ::= "local" (<lvar> ("[" <imm> "]")?)+ ";"
<atom>    ::= <dlabel> | <lvar> ("[" <lvar> | <imm> "]")?
```
ここで、 `<lvar>` のサイズを、固定値以外のものを確保するようにもできそうだが、実装側の負担が重いので、あまり導入されない？


また、局所変数以外の領域もあった方が嬉しい。
変数というものの有効な期間については議論の余地がかなりあるので、
どう実装するかはさておき、
- 局所領域：あるスコープが終わったら自動的に解放される。
- 共有領域：明示的に free を書く。

でわけることにする。
variable の方で書いた handle を明示的に書くのがかなりよさそうなので、それを使うことにする。
handle は value である。なので、 location 間を移動することができる。
ただし、 value はどこかには入れておかないといけないので、 alloc はポインタを入れる変数を指定する？
一方で、局所領域はスコープに属するわけだから、 value としての handle を確保してそれを追うことは難しい。
なので、場所性を前面に出したほうがいいため、上のようになった。
共有領域の場合は handle 値のように扱うことになる。

二つの扱い方の違いは、get/set について、
- 局所変数：引数がどんな名前の変数をしているかに基づく
- 共有領域：値に基づく、引数が変数の場合には、そこから値を読みだして使う。

```
<stmt>  ::= ...
  | "halloc" <atom> "to" (<lvar> | <dlabel>)
  | "hget" ((<lvar> | <dlabel>)) ("[" (<lvar> | <imm>) "]")? "to" (<lvar> | <dlabel>)
  | "hset" ((<lvar> | <dlabel>)) ("[" (<lvar> | <imm>) "]")? "from" (<lvar> | <dlabel>)
  | "hfree" <lvar>
```

ところで、局所変数も共有領域も、それらのアドレスが数値であるとする根拠はあまりない。
むしろ、意味論を与えるときには全然別にしてしまってもいい。
（もちろん実装の側では全部数値とかに落とし込むことになるが、）

## 制御構造
ここまでブロック中心の世界で生きてきた。
特に制御においては、 goto を使ってプログラミングをしているが、もうちょっと読みやすい方法を考えたい。

これの一つが、 while/for/do-while/loop などのループ構造と、break/continue によるループの制御である。
これらは実質的に、ブロックと制御の糖衣構文である。

## 引数・返り値
