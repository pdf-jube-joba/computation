ラムダ計算とは、ラムダ項と呼ばれる式と、その間の"変換"と呼ばれる関係式により、式をどんどん変形していく計算モデルである。
**多分今紹介している中では一番わかりにくい。**

- ラムダ項は変数・関数の宣言・関数の関数適用、みたいなもののみを使って作られる
    - 変数は `x` とか `y` とか
    - 関数の宣言はちょっと独特で、 `f(x) = x + 1` を `\x. x` のように書く。
    - 関数の適用も独特で、 `f(5)` を `(f 5)` のように書く。
- ラムダ項は現れる変数を（その束縛に注意しつつ）適当に変更してよい
    - `f(x) = x + 1` と `f(y) = y + 1` が同じ関数であるのと同じように、 `\x. x` と `\y. y` は同じとみなす。
- ラムダ項はその中に関数の適用があると、変数の置き換えを行う。
    - `f(x) = x + 1` としたとき `f(5)` はまず書き換えると `5 + 1` になるのと同じように、 `(\x. x + 1) 5` はまず書き換えると `5 + 1` になる。

説明にはわかりやすく `+` を使ったけれど、
ふつうのラムダ項には実際はそういうものがない。

## 具体例
わかりやすい例が全然ないので、とりあえずいろいろ動く例を載せた。

<div data-model="lambda_calculus">
<script type="text/plain" class="default-code">
(\x. x) y
</script>
</div>

次はちょっと長い。
自然数を次のようにラムダ項に解釈する。
- \(0\) は `\s. \z. z`
- \(1\) は `\s. \z. (s z)`
- \(2\) は `\s. \z. (s (s z))`
- \(3\) は `\s. \z. (s (s (s z)))`
こう考えると、 \(s(n) = n \mapsto n + 1\) を表す関数は、 `\x.\y.\z. (y ((x y) z))` とすればいい。
\(s(2)\) はそうすると次のようになる。

<div data-model="lambda_calculus">
<script type="text/plain" class="default-code">
(\ x y z. (y ((x y) z))) (\s z. (s (s z)))
</script>
</div>

ともかく step を押すと、ちゃんと \(3\) に対応する表現が得られている。
