ふつうの CPU は無限を考えなくていいし、プログラミング言語も別に考えなくていい。
ここでは自然数とかを扱いたいのでもうちょっと工夫する。

まず問題点
- メモリセルに入るのが有限bitでメモリも有限なら、絶対にチューリング完全にはならない。
- メモリが無限にあったとしても、そこにアクセスできないなら無理
    - 例： pc が自然数で += 1 ができるとしても、
        かなり遠くにあるメモリに入っている値を読みだすための指定ができないといけない
    - relative な指定ができるならいいかもしれないが...
- 1. メモリセルは有限で、命令長を無限にする
    - 可変命令長みたいになっていれば大丈夫という感じ
- 2. メモリセルは無限で、メモリが有限
    - 形式的には扱いやすくても、論理回路で自然数の入るメモリを書くのは大変

## データとコードについて
計算モデルはデータとコードを分けるかどうかで大きく分けることができて、
ラムダ計算、ノイマン型のCPU（を中心としたメモリとかも含めた機械）はデータとコードを分けず、コード単体で動かすことができる。
データとコードを分けない場合には、データを処理させるためにはデータをコードに埋め込むことになる。
例えばラムダ計算なら、コード \(M\) とデータ \(N\) に対して \((M N)\) という"コード"を生成して、コード単体を実行していることになる。
ノイマン型も同じで、命令とデータは同じアドレス空間上に置かれている。

これができると、「これからさきに実行するコード部分を書き換える」ことができるようになる。
例：ローダーはデータとしてのコードを読み、データとして書き換え、それをコードとして読みだしたりする。

1. `01110010` というデータを読み出す。（実はそれは命令としては「あるアドレスにあるメモリを読み出す」操作である。）
2. `01110011` に変更する。（命令と解釈した場合の読み出す先のアドレスを書き換えている。）
3. 次の命令で修正した命令が入っているところにジャンプする。

## もうちょっと考える
universal Turing machine にせよ、 VM にせよ、
データ領域にあるものをコードと思うことで動作するような機械が作れてしまうので、
コードとデータを分けたところで、上のような問題はつねに発生しうる。
いわゆる reflection （データの側から実行時の動作をある程度自由に制御する仕組み）は、
Turing 完全な計算モデルならできる。
（と人間から解釈できるような動作を行うコードが存在するはず。）

ただし、普通はある種の `as_code(data)` みたいな関数を経由したり、
内部のコード内の制御がデータの側に明かされていることが前提（どんなコードをしているかがデータ側に最初から伝えられていて、どんなデータをしているかがコード側に伝えられている）となっている。
これを踏まえて、逆に、機械語の側に対してもっとデータとコードを分けて考えるようなモデルを与えることもできる。

それがハーバード型とか modified なハーバード型になっている。
例を挙げる
- メモリを2つ用意して、一方にコードがありもう一方にデータがある。以下は variant
  1. コードの側では、 load, store はデータの側に対してしか行えない、ジャンプ先は変更ができない
    - ただしこの場合でも、「データの側で 0 か 1 か → コードの側のジャンプ先の変更」ができるので、
      どんなコードが入っているかを知っていれば、実質的な reflection ができる。
      というか、これぐらいはできないと使えない。
  2. ジャンプ先をデータの側から指定するなど。
  3. load, store をコードに対して行う、2つのメモリの swap があるなど。
  4. コード側のメモリとデータ側のメモリが連結している（これがノイマン型）。
    - ただし、現代のものだと無造作にジャンプできたりはなくて、
      メモリの領域は実行可能かどうか、
      現在の動作モードでは読み取り可能かどうかなどが設定されていることがある。
- そもそも別の主となる機械に従属しているので、外部からコードとデータを与えられて、基本的な分岐以外はできない機械もある。
  - GPU とか NPU とか TPU とか CGRA とか？
