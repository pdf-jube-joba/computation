## 制御構造
ここまでブロック中心の世界で生きてきた。
特に制御の分岐では、 goto を使ってプログラミングをしているが、もうちょっと読みやすい方法を考えたい。
これの一つが、 loop/while/do-while/for などのループ構造と、break/continue によるループの制御である。

ループの構造
- loop: これは普通に、ただループするだけ
- while: あるブロックを条件を満たさなくなるまで実行する
  - ただし、典型的には（というかこうなっていないものを見たことはないが）、その条件の判定は while の先頭に戻ってきたときに判定される。
- do-while: while と同じ。ただし、ブロックの実行"後"に判定が行われる。
- for: while とだいたい同じ。違うところもある（言語による）。初期化、ループする条件、ループ時に行う処理などを書くとか。

ループの制御
- break: ループを強制的に終了して、ループの次の文に移る。
- continue: ループ内のそれ以降の制御を打ち切り、もう一度ループの発生に戻る。

これらは実質的に、ブロックと制御の糖衣構文である。
```
i = 0;
j = 0;
loop {
  i += 1;
  if i == 10 {
    break;
  }
  if i % 2 == 0 {
    continue;
  }
  j += 1;
}
// i == 10, j == 4
```

これを goto で書くとこうなる。

```
i = 0;
j = 0;
@loop {
  i += 1;
  if i == 10 {
    goto @loop_end
  }
  if i % 2 == 0 {
    goto @loop
  }
  j += 1;
}
@loop_end {
}
```
goto になれている人なら後者の方が読みやすいかもしれないが、以下の観点から break/continue は楽。
- 単純な構造なら読みやすい
- ループ名によらないので自動生成しやすい。

## 入れ子の構造
ループを入れ子にすることができるといい。
```
i = 10;
j = 10;
k = 0;
while (i != 0) {
  i -= 1;
  j2 = j;
  while (j2 != 0) {
    j2 -= 1;
    k += 1;
  }
}
```

### どれぐらいループを抜けるか？
ループ構造にはラベルがついていて、 break/continue ではそのラベルを指定できるとうれしい。
```
loop 'outer: {
  loop 'inner: {
    for i in 0..10 'nest: {
      if i == 8 : break 'outer;
    }
  }
}
```
みたいな。
これも、実質的には糖衣構文のはず。

ところで、これはラベルと goto を使っているのと同じに見えるが、
実際には、構造が flat から nest（入れ子） になるだけでかなり具合がいい。
通常想定されている制御への入り方以外を考慮する必要がなくなっているので。
なので nest ができるラベルと goto というだけでも、入るべきでない入り方を防げるならそれでいい気がする。
```
@label1 {
  i = 10;
  j = 20;
  @label1_1 {
    // ここでは i == 10 であることを前提にプログラミングしている。
  }
}

@label2 {
  i = 20;
  j = 10;
  @label2_2 {
    goto @label1_1; // `i=10` による初期化が済んでないのにジャンプしているように見える。
  }
}
```
こういうのを防ぐという観点では、ある制御の単位からのジャンプ先では、祖先と対等な位置にあるもののみ jump 可能にすればいい。
ただ、それを抜きにしても、 goto 以外の制御構造は読みやすいので、使えるならそこを使った方がいい。

## 単なる制御の単位の宣言としてのスコープ
これは局所変数の話とも被るが、上のようなジャンプを目的としてラベルを書く以外に、
見やすくなったりミスを防ぐ目的でも、入れ子を作ることができてもいい。
特に、変数にアクセスできるかを制限することができるとよい。
変数がどれぐらいのところで有効かという範囲をスコープという。

```
'outer: {
  local i = 0, j = 0, k = 100;
  :'inner1 {
    local i_inner1 = 10;
    // i,j,k にアクセスできる
  }
  :'inner2 {
    // i,j,k にアクセスできる
    // i_inner1 にはアクセスできない
  }
}
```

変数の名前を解決するやり方によっては、こういうことができる言語もある。
```
fn inc_x() {
  // この関数単体では `x` がないのに `x` について言及している。
  x += 1;
}

fn main() {
  large_scope {
    local x = 10;
    inc_x();
    // x == 11 になっている？
    small_scope {
      local x = 5;
      inc_x();
    }
    // x == 6 になっているのか、 x == 11 のままなのか？
  }
}
```

## 局所変数と return value について
制御の単位で共通で用いる変数があるとよい。
典型的には、制御の初めに宣言する。
ある制御の単位においては、外部から入ってくる分には必ず上から順に実行されるようにしておけば、
その初期化がちゃんとされるはず。

### return value?
あと、できれば、break with value ができるといい。
```
let i = :'outer {
  :'innner loop {
    :'nest for j in 0..10 {
      if j == 8 {
        break 'outer j;
      }
    }
  }
};
// i == 8
```

これだけ注意が必要で、
もし break に飛ばなかったときに最終的に何が返ってくるかが未定になりうる。
それへの対応としては、わかる範囲でチェックしてそれが起こらないことを保証するか、
変数は常に初期値で初期化されていて、 break は書き込みしてから break をしていると思うかどうか。
さっきのコードならこう。

```
let i = 0;
:'outer {
  :'innner loop {
    :'nest for j in 0..10 {
      if i == 8 {
        i = j
        break
      };
    }
  }
}
```
