## アセンブリ
いわゆるアセンブリ言語を紹介する。
アセンブリ言語はだいたい機械語と命令が1-1に対応している言語のことだが、
そのまま01の列とかを書くのはめんどくさいから、 mnemonic と呼ばれるような記述で楽に書く。
これに加えていろいろな機能がある。
1. 制御のブロックにラベルを付ける
2. 定数やいくつかの場所に名前を付ける

とかね。
ラベルはあとから番号を振ったりして、代入する。
"どこに何を置くか"だけ名前が付けられるようにした言語と思っていい。

アセンブリ言語がどう動くかを単体で定めることはなくて、どう機械語に翻訳されるかだけが議論されていることが多い。

<div data-model="symbolic_asm">
</div>

機械語のレベルではデータとコードには区別がなかったとしても、
人間の扱う側ではコードとデータを分けたほうが嬉しいので、
"プログラミング"を行う側のモデルとしてはコードとデータを分けることにすることが多い。
アセンブリ言語もその典型というか、 `.text` というセクションにコードをおいて `.data` というセクションにデータを置くなど、
人間が書いて人間が読んで、その意図を長く保つための工夫がある。

問題は、アセンブリ言語自体にはデータとコードの分かれ目がある（ように扱いたい）のに、それがコンパイルされる先にはその差がないこと。
そうなると、アセンブリ言語の側では意味が分からないように思えるただの数値だが、コードとしては意味を持つことがある。
`.data` というセクションに置かれているデータに対して、それをコードとして読む、みたいなことが行えてしまう。
他の例としては、dynamic dispatch とかは、データの中で「コード上のどこに飛ぶか」をポインタ（値）として持っている。
それはコードの側でどこに関数が配置されるかを事前に知ってないとできない。
その場合に、それはアセンブリ言語単体での意味論として正しいのか？
もちろん、最終的に機械語になるのだからそもそも意味のない問いと思うこともできて、
基本はそう考えるほうが筋がいい。
（整合性があるから。）

ただ、そういう"職人芸"じみたことは混乱につながるので、
アセンブリ言語単体での意味論としては、 `.data` と `.code` の越境を許さない形で定義して、
そこを超える場合には未定義としてしまうのが、素直な気がする。
なので、以降は、 **アセンブラ単体ではコードとデータがきちんと分かれている**ものとして、動作を議論したい。

> [!Note]
> 未定義というのはどういうことかというと、どう動くかを指定していないということ。
> そのため、アセンブリ単体の意味論としては特に定まっていないが、機械語に翻訳した際には動くかもしれない。
> ただし、"ちゃんと"動くかはわからない（例えば、未定義なことをやったら Steam にある `A` から始まるゲームがすべて削除されるかもしれない、もちろんそんなことが起きると信じる根拠はないけれど）。
> こういう未定義という言葉は、言語ごとに独特の意味論を持っているので注意すること。

ただし、このアセンブリに対応する機械語では"関数ポインタ"のようなものが使えるようになっている：
jump 時に飛ぶ先を汎用レジスタに入っている値から指定することができる。
これは後述する分類のうちの、 2. になっている。
