## スコープと局所変数
ここからは、仮想レジスタをあまり意識しないで使いたい。
特に、load/store はあまり書きたくないので、
下の flow_ir に落とし込めるようにしつつ、 load/store は使わない方針で行く。
正直、これだけやると、仮想レジスタの場合と何が違うのかがわからない。
load/store が消えたのと、値の共有がされなくなっただけ。
とりあえず書くことにすると、こんな感じ。
（普通に、 load/store が消えただけ。）
```
<clabel>  ::= "@" <string>
<dlabel>  ::= "@." <string>
<lvar>    ::= "$" <string>

<atom> = <dlabel> | <lvar>

<local>   ::= "local" <lvar>+ ";"
<stmt>    ::= (
  <var> ":=" <var> <op> <atom>
    | "Nop" | "Halt" | "Readpc" <var>
  ) ";"

<cond>    ::= <atom> "<" <atom> | <atom> "==" <atom>
<jump>    ::= <var> | <clabel>
<cont>    ::= 
  "goto" <jump> ";"
  | "if" <cond> "then" <jump> ";" <cont>
<block>   ::= <clabel> "{" <local>? <stmt>* <cont> "}"
<static>  ::= <dlabel> <imm> ";"

<program> ::= <static>* <block>*
```
実は、値の共有がされなくなったのはかなりまずい。
どうしてまずいかを考えると、ブロック間での計算結果の共有に、 static を使う必要が出てきてめんどくさい。（できないわけではない。）
これの解決方法として次のものがある（これは実質的には同じことをやっている。）
- ブロックに引数を持たせる
- 各ブロックで共有する用に専用のスタック領域を用意する

ここでは別の動機もあるので、ブロックの nest と局所変数を許すことでこれを解決する。
ざっくりいうと、「このブロックのまとまりでは共通してこの変数が使える」ことを宣言できるようになる。
別の動機：この文を書いた意図を忘れた。

```
<stmt>    ::= (
  <var> ":=" <var> <op> <atom>
    | "Nop" | "Halt" | "Readpc" <var>
    | "block" <block>
  ) ";"
<block>   ::= <clabel> "{" <local>? <stmt>* <cont> "}"
```
局所変数はジャンプ時にどうなるかというのがめんどくさい。
例えば、親が同じブロックであれば、自分のところで確保した局所変数は全て扱えなくした状態でそこに飛べばいい。
同じように考えると、親の親を共有している...とかはいける。
ブログラム全体はブロックの入れ子で木構造をなしているので、ジャンプに対しては、
祖先からフラットに進んだところだけジャンプができるとしておく。

正直これだけあれば結構なことができるので、ここで終わってもいいが、これだとあとで困る。
局所変数は領域でとって、そこに index でアクセスしたほうが嬉しい。

```
<local>   ::= "local" (<lvar> ("[" <imm> "]")?)+ ";"
<atom>    ::= <dlabel> | <lvar> ("[" <lvar> | <imm> "]")?
```
ここで、 `<lvar>` のサイズを、固定値以外のものを確保するようにもできそうだが、実装側の負担が重いので、あまり導入されない？


また、局所変数以外の領域もあった方が嬉しい。
変数というものの有効な期間については議論の余地がかなりあるので、
どう実装するかはさておき、
- 局所領域：あるスコープが終わったら自動的に解放される。
- 共有領域：明示的に free を書く。

でわけることにする。
variable の方で書いた handle を明示的に書くのがかなりよさそうなので、それを使うことにする。
handle は value である。なので、 location 間を移動することができる。
ただし、 value はどこかには入れておかないといけないので、 alloc はポインタを入れる変数を指定する？
一方で、局所領域はスコープに属するわけだから、 value としての handle を確保してそれを追うことは難しい。
なので、場所性を前面に出したほうがいいため、上のようになった。
共有領域の場合は handle 値のように扱うことになる。

二つの扱い方の違いは、get/set について、
- 局所変数：引数がどんな名前の変数をしているかに基づく
- 共有領域：値に基づく、引数が変数の場合には、そこから値を読みだして使う。

```
<stmt>  ::= ...
  | "halloc" <atom> "to" (<lvar> | <dlabel>)
  | "hget" ((<lvar> | <dlabel>)) ("[" (<lvar> | <imm>) "]")? "to" (<lvar> | <dlabel>)
  | "hset" ((<lvar> | <dlabel>)) ("[" (<lvar> | <imm>) "]")? "from" (<lvar> | <dlabel>)
  | "hfree" <lvar>
```

ところで、局所変数も共有領域も、それらのアドレスが数値であるとする根拠はあまりない。
むしろ、意味論を与えるときには全然別にしてしまってもいい。
（もちろん実装の側では全部数値とかに落とし込むことになるが。）

## 制御構造
ここまでブロック中心の世界で生きてきた。
特に制御の分岐では、 goto を使ってプログラミングをしているが、もうちょっと読みやすい方法を考えたい。

これの一つが、 loop/while/do-while/for などのループ構造と、break/continue によるループの制御である。
- loop: これは普通に、ただループするだけ
- while: あるブロックを条件を満たさなくなるまで実行する
  - ただし、典型的には（というかこうなっていないものを見たことはないが）、その条件の判定は while の先頭に戻ってきたときに判定される。
- do-while: while と同じ。ただし、ブロックの実行"後"に判定が行われる。
- for: while とだいたい同じ。違うところもある（言語による）。

これらは実質的に、ブロックと制御の糖衣構文である。

ループ構造にはラベルがついていて、 break/continue ではそのラベルを指定できるとうれしい。
```
:'outer {
  :'innner loop {
    'nest :for i in 0..10 {
      if i == 8 : break 'outer;
    }
  }
}
```
みたいな。
これも、実質的には糖衣構文のはず。

あと、できれば、break with value ができるといい。

```
let i = :'outer {
  :'innner loop {
    'nest :for i in 0..10 {
      if i == 8 : break 'outer i;
    }
  }
};
```

これだけ注意が必要で、
もし break に飛ばなかったときに最終的に何が返ってくるかが未定になりうる。
それへの対応としては、わかる範囲でチェックしてそれが起こらないことを保証するか、
変数は常に初期値で初期化されていて、 break は書き込みしてから break をしていると思うかどうか。

## 手続き（引数と返り値）
ブロックの途中で、他のブロックを呼び出す際に次のものが欲しい。
- 変数に値を設定しつつ
- 必要に応じて結果を受け取る

これを実現するのが、引数と返り値である。

### 動的スコープの話

### 値渡しと参照渡し

### 手続きの再帰性について
