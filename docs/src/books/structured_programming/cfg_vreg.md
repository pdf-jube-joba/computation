## レジスタを仮想化
アセンブリのまま使うと、レジスタが有限個になっていることで、
今から使おうとしているレジスタに、後から使う必要のある値が入っているという問題が起きる。
その場合、レジスタ（に入っている値）を一度メモリに退避させて、
必要に応じてまたレジスタに戻す必要がある。
これを自動的に判定してアセンブリを挿入することができれば、
レジスタ間の移動やメモリとのやり取りを本質的な部分に絞ることができるし、
レジスタ自体も実際に存在するよりも多くの数を仮想的に扱える。

```
BB: {
  x = y + 1;
  z = x * y;
  y = z + x;
}
```

こういう形で書かれたものを、 3-address 形式という。
変数は基本的に突然出てくる。
また、初期値についても、実行したら一切明示的な代入がないまま使われていることがわかったりする。
これらはある程度解決できる。
- どんな変数が出てくるのかは一度プログラムを眺めればわかる。
- 初期値については、\(0\) が入っていると決めておく。

これらに加えて、
- SSA 形式への制限：すべての変数は代入が一度だけされるように制限する。
  - これは、 jump 先が table からだと実行時にしかわからないようなこともありそうだが、 static にわかる範囲で解決すれば十分？
- \(\phi\) 関数というものを書いて、ブロックの合流地点において、各ブロックの変数を引き継ぐためにマークする。
  例えば `BB1: {y1 = 2; Goto BB}, BB2: {y2 = 3; Goto BB}` みたいな2つの異なるブロックに対して、
  `BB: {y = phi(y1, y2)}` のように書くことで、
  `y` は「BB1 を通った場合には `y1` から来ていて、 BB2 を通った場合には `y2` からくる」ことを表す。
  数学的な関数というよりも、意味を明示するために書いている。

などを入れることが多い。

> [!Tip]
> ここら辺はコンパイラの Intermediate Representation とか Intermediate Language と呼ばれる。
> それで検索するととにかくたくさん出てくる。
> llvm cranelift qbe
> ほかにも小さいものは検索すればたくさん出てくる：bril fmm
> 各言語ごとにも、 IR がたくさんある。

> [!Note]
> ここらへんは実用の世界がかなり近いので、
> "理論側"でさえも形式的証明に使えるようなものは、実用を考えた、込み入ったものが多い。
> 教育用、あるいは簡単な PoC としての実装さえも複雑になっていて、
> （計算モデルといえばチューリングマシンみたいな）共通認識として使える簡易なものは見つからなかった。
> 特に必要を感じないのかもしれない？（あるいは、自明？）
> - メモリそれ自体の線形性がなくなった場合は、この後で話す関数とスタックフレームの話で困ることになる。
>   単純に言うと、変数 `x` の"次の変数"（や前の変数）みたいな概念が使える言語でないと、これからの議論で困る。
>   これは単に `fn new(set: Set<Var>) -> Var` があること以上の意味論を持っているものの、
>   メモリの境界を超えるような操作はしてはいけないはずなので、
>   "少なくとも"線形で無限に並んだメモリがある、ことぐらいは議論の中で必要そう。
> - また、"変数が無限"の意味も難しくて、各コードごとに有限の変数しか現れないのであれば、
>   はじめから静的に `.data` にラベルで割り当てたのを implicit にレジスタを経由するのと変わらない。
>   なぜそうしないのかというと、そもそも"そうする"ことはコンパイルのやり方の問題（意味論が保たれるか）だから。
>   ここら辺が難しいところで、3-address 形式もアセンブリと同じように、機械語にどう翻訳されるかがその意味の中核をなすわけで、
>   それ単体で何を保証しているか、共通の見解として提示できるような formal で simple な言語はない。
> - AI によると他にも、 SSA 形式に限らないで意味論を考えることはできる
>   （それはそう、環境を変数から数字へのマップにすればいい）ものの、
>   その場合だとあまりうまくいかないらしい。
>   どうしてうまくいかないのかはごにょごにょ言ってるがよくわからなかった。
>   確かに SSA 形式でないものまで含めるとコンパイルが壊れるようなことをやることになるが、
>   「hogehoge として定義される言語のうち SSA 形式のもの」に限ればコンパイルが意味を保っているとしてもおかしくはないはずなのに？
>   なんかうまくいかないことは学習されているようなので、インターネットではおそらく、なんかうまくいかないこと自体は共有されているみたい。
> 結局のところ、実用が近すぎるのでこういうことを考えるのは無駄みたい。
> 「どうコンパイルされるか」だけが正義のような感じ。

ここからは、何と戦っているのか全く分からない話が延々と続く。

## refinement
とりあえず `.data` のラベルとレジスタを統合して、全部変数として考えてみる。
今考えているアセンブリは Harvard 型ではあるものの、
jump by register value (JMPR) があるので、これを生かすためには `.text` ラベルは残す。
3-address 形式にするとこんな感じ？

\(\begin{aligned}
\NT{atom} &\defeq \NT{var} \sp | \s \NT{imm} \\
\NT{stmt} &\defeq ( \\
    & | \sp \NT{var} \sp \T{:=} \sp \NT{var} \sp \NT{op} \sp \NT{var} \\
    & | \sp \T{nop} \sp | \sp \T{halt} \\
    & | \sp \T{readpc} \sp \NT{var} \\
    & ) \sp \T{;} \\
\NT{cond} &\defeq \\
    & | \sp \NT{atom} \sp \T{<} \sp \NT{atom} \\
    & | \sp \NT{atom} \sp \T{=} \sp \NT{atom} \\
\NT{cont} &\defeq \\
    & | \sp \T{goto} \sp \NT{label} \\
    & | \sp \T{if} \sp \NT{cond} \sp \T{then} \sp \NT{label} \sp \T{;} \NT{cont}
\end{aligned}\)

ここには確かに load/store がない。
どう動くかについても単純に、変数から数値への写像を環境とすれば適当に定義できる。
ただこれだと、ちょっと扱いにくい。
どう扱いにくいかというと、最初に登場した変数以外にアクセスができない。
これをいろんな言語のコンパイル先に選ぶことが難しい。

もともとの動機は、
- 本当にメモリに入れておく必要があるもの
- 別にずっとレジスタにいてもいいもの

が同じになっているのが大変というところもある。
計算のために一時的に作られる値にもメモリを割り当てることになっている。
そのため、アセンブリ言語の次の言語として使うのであれば、 `.data` セクションがあるのとは**別に**、
レジスタが無限にあると考えたほうがよい。これを仮想レジスタという。
メモリに名前を付けるのはラベル、計算手順を記述するのはレジスタと分けるといい。
なので、さっきの"変数の無限化"は言い過ぎで、レジスタが無限にあるように記述するのがいいらしい。

そうなると、 load/store が復活する。これはしょうがない。
レジスタの個数も退避も考えなくてよくなるのでまあうれしい。
これを加えるとこんな感じの言語になる。（レジスタなので `%` をつける。）

\(\begin{aligned}
\NT{var} & \defeq \T{%} \sp \NT{string} \\
\NT{stmt} & \defeq \cdots \\
    & | \NT{load} \sp \NT{var} "from" \NT{label} \\
    & | \NT{store} \sp \NT{atom} "to" \NT{label}
\end{aligned}\)

- メモリは場所：アドレスが取れて、 load/store でアクセス。
- 仮想レジスタは値の記述：アドレスは取れない。

### 線形メモリ
このままでも全然チューリング完全ではあるが、"次の"レジスタという概念にはアクセスできないので、
引数や返り値のある再帰できる言語を考えたときに、この言語をコンパイルすることができない。
（これから困るという話をしているので、あまり意味が分からないかも。）
また、ヒープ（というか、別のアドレス空間の線形メモリ）があると使いやすい。

仮想レジスタ自体には"次のレジスタ"という概念はないほうがいい（うまく説明できない。）
代わりに、仮想レジスタ以外の"メモリ"っぽいところをもっと自由にアクセスしたい。
これに対する選択肢としては、次のものがあげられる。
1. `<label>` でアクセスしている領域を無限に長い線形メモリとしてしまって、
  静的に割り振った後の残りの部分にスタックやヒープ用のメモリが使えるようにする。
  具体的には、 `"load" <atom> "to" <atom>` を許す。
  これはつまり、アセンブリ言語の側ではそのまま"数値"でメモリにアクセスできていたものを、
  さっきはラベル以外でアクセスできなくなったものを、
  また数値でアクセスできるようにしただけ。
2. `<label>` のある場所以外にも増やして、スタックと線形メモリを加える。
  「機械語の側での実際のメモリ位置」に直接触らせるとまずいので、
  別の命令体系を用意してそれ経由でしかアクセスできないようにする。
  - スタック： push, pop で（1つの）領域の大きさを制御する。
  - ヒープ： malloc, free で領域をもらったり返したりする。
  - これらをもっと扱いやすいようにするには、チャンクの概念があればいい。

これらの話を踏まえたうえで、 1. の方が単純そうなのでこれにする。
ちゃんと書くと、
- これまでのラベルの考え方：環境は \(\text{String} \to \text{Value}\) として、これをプログラムの中で変更していく。
  `"load" <label>` しか許されないように、「このラベルの次の場所」とかは指定できない。
- これからのラベルの考え方：アセンブリと同じように、ラベルは、
  単に線形メモリの上に名前を付けているだけなので、アドレス経由でのアクセスを復活させる。

### コードへのジャンプの自由化
これに加えて、 `"goto" <label>` だけだとどの関数に飛ぶかを後から指定するのがちょっとめんどくさくなる。
どの関数を呼ぶべきかがデータに含まれているとか。（関数テーブル付きのオブジェクト。）
だから、 `<label>` で指定されていたジャンプ先についても変更できるといい。
`<var> | <label>` に飛べるようにしておく。

ラベル分けて、最終的にはこんな感じになる。

```
<label>  ::= "@" <string>
<var>     ::= "%" <string>
<atom>    ::= <var> | <imm>
<addr>    ::= <var> | <imm> | <dlabel> 
<stmt>    ::= (
  <var> ":=" <var> <op> <atom>
  | "load" <var> "from" <addr>
  | "store" <var> "to" <addr>
  | "Nop" | "Halt" | "Readpc" <var>
  ) ";"
<cond>    ::= <atom> "<" <atom> | <atom> "==" <atom>
<jump>    ::= <var> | <clabel>
<cont>    ::= 
  "goto" <jump> ";"
  | "if" <cond> "then" <jump> ";" <cont>
<block>   ::= <clabel> "{" <stmt>* <cont> "}"
<static>  ::= <dlabel> <imm> ";"

<program> ::= <static>* <block>*
```

ところでこれをやると、 goto の先がラベルとは限らない。
なので、普通の最適化がしにくくなる。

とりあえず、ブロックの途中には飛べないとしておく。

> [!Note]
> アイディア：
> SSA 形式の判定時には、すべてのブロックを見る必要がある。
> 多くのレジスタはブロック固有の名前を仮想レジスタに持たせることになるから、それをするぐらいなら、
> phi と合わせて、「このブロックで用いる局所的な仮想レジスタと、他のブロックから入るときのその出自」を宣言する。
> それ以外はそもそもブロック間で共有されないとしておくこともできる。
> `<ldecl> ::= (<var> "from" (<label>)+ )`
> `<block> ::= <label> <ldecl> "{" <stmt>* <cont> "}"`
> 実行時にジャンプ先が決定されるとしても、ジャンプ先で指定されているレジスタ以外は共有されないと考えていいので、ずいぶん楽になる（気がする？）
> でもこれをやると、引数付きの局所変数と同じようなものなので、ここでは別にする。

スタックとかヒープについては、高級言語からコンパイルするときにどうにか実装してほしい。
例えば、 static のところに @stack_start と @stack_now とかを作って、そこをもとにpush,pop をするとか。
ヒープの方も、どうにか頑張ってほしい。
bump allocator にするとか。

### 気が付いたこと
てか load/store 書きたくない。
式を書いた時点で多分何が必要かはわかるはず。
書かなくてよさそう。

それと place/value という考え方が染みついていて、他の概念が考えられていない。
一応他の考え方についても聞いた。
- 全部を値をしてデータフローにする：メモリも巨大な値
  - 全ての文が (Memory, Other) -> (Memory, Other) みたいに解釈できる。
  - これはほぼ operational semantics のこと？まあそれ自体はこっちも同じ。
- メモリ操作だけ副作用が発生するものとして扱う、それ以外は値の記述。
