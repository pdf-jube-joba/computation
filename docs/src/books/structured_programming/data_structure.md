単にメモリセルに名前を付けるよりも、
まとまった単位でメモリセルを扱うことができるようになると、意図が伝わりやすくなる。
場合によっては、機械的な検証で誤りを見つけることが容易になったりもする。
こういう、メモリの扱い方を改良するために用いられる機能として、データに型を付ける言語機能があった方が良い。
（ただし、それ以外の目的でデータに型を付けることもあるので、この目的で導入されたもののみをデータ型というわけではない。）

現代的なプログラミングで使われる代表的なデータ型はこんな感じ。

- 構造体（直積型）：複数のデータ型を同時に持っておく。
- 列挙型（直和型）：複数のデータ型のうちどれか1つを持っておく。
- 配列：同じ種類のデータ型を複数持っておく。

これを導入するためには、言語処理系にどのようなデータ型を導入するのか教える必要がある。
これが、型の宣言というもの。
例えば構造体の場合はこんな感じ。
```
struct A {
  x: number,
  y: number,
}

z = A { x := 1, y := 2 };
u = z.x;
```
基本的には、型がどういうものかを処理系に伝えなければいけない。

## 直積型
複数のデータ型を並べ、各個別のデータへのアクセスできるようにする。
あまり凝ってない。

## 直和型
ある異なるデータ型に対して、それらのうちのどれが入っているかを述べる。
凝ってる。
具体的には、
それらのデータ型のうち、実際にどれが入っているかを判定出来たりできなかったりする。

使う側としてはこんな感じ。
```
struct Point {
  x: number,
  y: number,
}
struct Circle {
  x: number,
  y: number,
  r: number
},

enum Shape {
  Point,
  Circle,
}
```

使う側は「もしこの variant だった場合は...」という形でプログラムを述べる必要がある。
```
fn sq(s: Shape) {
  s.r += 1; // s が Circle であることが確定してないので、書いてはいけない。
  if Shape::Point == s {
    // s が Point だった場合
  }
  if Shape::Circle == s {
    // s が Circle だった場合
  }
}
```
関数の利用に関する契約として `Point` が引数に来うることがわかっているので `x.r` に無条件に触るべきではない。
（もし `x: Circle` しか来ないから `x.r` にアクセスしてもいいのなら、初めからそのように引数を書くだろう。）

ところで、今のコードは `x` がどれであるかを判定している。
意味の側ではさておき、実装する側は判定をどうするかというと、追加の情報としてタグをつければいい。

> [!note]
> 今のコードの場合、どっちであるかは判定できなくても、
> `s.x` には少なくともアクセスできると思った。
> オブジェクト指向？な考え方につながっている気がする。
> コードの要件が `.x` と `.y` を持てばどんなものでも正しいロジックになっていると主張するなら、
> それは外部を見る振る舞いのみからコードのことがわかっているので、列挙型を使う意味がない。
> その点で列挙型は、「これらのうちどれか」であることを保証できるのでいい。
> なら eliminator で計算できることは列挙の必須？

## 配列
同じデータ型が並んでいて、「 _何_ 番目のものにアクセスする」ことができるのが配列である。
普通は無限に長くないので、配列が抱えていないところにアクセスしうる。
特に、実行時に何番目にアクセスすることになるのかがわからない場合は、
アクセスできる範囲外へ配列外へのアクセスといって大体やってはいけない。

```
fn main() {
  a = [10, 2, 5, 3]
  x = a[0] // x == 10
  y = a[3] // y == 3
}
```

多くの言語は 0-index といって、配列の一番最初のものから `0` で数え始める。
上の例だと、 \(0, 1, 2, 3\) 番目は \(10, 2, 5, 3\) になる。

## 再帰型
これだけ毛色が違うが、一応紹介しておく。
型の定義に自分自身を含むような再帰的な定義をしているものを再帰型という。
```
data Tree {
  Tree(number, Tree)
}
```
