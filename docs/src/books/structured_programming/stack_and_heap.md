## メモリの使い方：
単にラベルがついているところ以外も触れるようになったからといって
（しかも順序がついているからといって）無秩序に使うのではなくて、
用途ごとにいろいろ切り分けるのが良い。

> [!Tip]
> 用語のメモ
> - セルの前後のないメモリ：\(\mathbb{S} \to V\) みたいになっていて \(\mathbb{S}\) には何の構造もない... store, environment, symbol talble, mapping
> - セルの前後という概念があり、現在位置からの relative なアクセスしかできない：\(\mathbb{S} \to V\) で \(\mathbb{S}\) は affine ... relative-address memory
>   - スタックはここ、ただし、長さにアクセスできるなら絶対位置がわかるのと同じ。
>   - affine memory とは言わないらしい。
> セルの前後以外に原点や絶対位置でのアクセスができる： \((0, n \in \mathbb{N}) \to V\) ... linear memory
>   - ヒープはここ。

スタックに対する典型的な操作：
- `spush(M: stack<V>): V -> ()` :セルを新たに追加して、そこに受け取った値を入れる。focus しているメモリの位置は進む。
- `spop(M: stack<V>): () -> V`  :セルを一つ失って、そこに入っていた値を放出する。focus しているメモリの位置は戻る。
- `sget(M: stack<V>): (n: number) -> () -> V` : focus 位置から見て後ろに \(n\) だけ戻ったセルについて、セルの値をコピーして放出する。
- `sset(M: stack<V>): (n: number) -> V -> ()` : focus 位置から見て後ろに \(n\) だけ戻ったセルについて、受け取った値を入れる。

ヒープに対する典型的な操作を考えるのは難しいのでおいておく。
多分領域ごとに見たら、 `get` と `set` とかしかないようなものに思えるはず。
今考えたいのは、単なる `malloc` とか `free` みたいなものなので、それを中心にした話。
static な領域とスタック領域を得た後に欲しくなるのが、残ったメモリ部分をもっと活用するために、"可変な"活用のできる領域である。
（実行時の話をずっとしている？それ以外の動機もあると思うけれど。）
- 実行時に欲しいサイズがわかる。
- 確保したときと使用するためにとっておく期間と使わなくなるときが実行時にわかる

余ったメモリ部分を全部そうやって使うのもいいが、「ここは使っているので他の部分を使ってください」みたいなことができるとうれしい。
これは、**新たに**別の固定サイズメモリ領域を新たに受け取るようなもの。
なので、余った部分を丸ごと管理する主体を作り、それを必要に応じて切り分けて**新たに**linear memory として切り出すなどのことをおこなってもらえるとうれしい。

とりあえず、ハンドルを基本にした設計としてこんなものを考えた。
- `halloc(M: heap<V>): () -> Handle` :管理している領域から新たにメモリセルを切り出して、そこへのアクセス権を返す。
- `hfree(M: heap<V>): Handle -> ()`  :アクセス権を受け取って、対応するメモリセルを使えないようにする。
- `hget(M: heap<V>, handle: Handle): () -> V` : アクセス権をもとに、対応するメモリセルから値をコピーして返す。
- `hset(M: heap<V>, handle: Handle): V -> ()` : アクセス権をもとに、対応するメモリセルに受け取った値を入れる。

ところで、言語として上のメモリを用いる場合は、スタックは変数に結び付けて、ハンドルは値として扱うのが一般的である。
そういう点で行くと、スタック自体もヒープと同じように、今ある領域から切り分けるような使い方の方が嬉しい。
こうなると、仮想レジスタとは別の変数という概念が出てくることになる。
（IR としては普通に push/pop を使うことも多く、関数の呼び出し前後で push/pop の数があっていれば変に caller の領域を壊してしまうこともないはず。）

こうなると、さっきの heap と同じような設計になっているように思える。（ signature は違うように思えるが、実質的には同じ。）
- `salloc(M: sheap<V>, variable: Variable): ()` :管理している領域から新たにメモリセルを切り出して、そこへのアクセス権と変数を結び付ける。
- `sfree(M: sheap<V>, variable: Variable): ()`  :管理している領域のうち、変数に対応する領域を解放する。

違いは、 Handle は値なので受け渡しができること、変数は受け渡しができないこと。
```
fn f {
  halloc(%1); // %1 に handle 値が代入される
  return %1;  // この関数内で作った handle 値を返却する ... 合理的
}

fn g {
  salloc($x); // $x という変数とメモリ領域が結びつく
  return $x;  // ここで行っているのは、変数 $x に入っている値の return
  // salloc で作られた領域にはアクセスできなくなってもよい。
}
```

あとは全体的にサイズを指定してアクセスができるようになればいい。
