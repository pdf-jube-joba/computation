# 万能チューリングマシン
実際に構成するのはめんどくさいのでやらないが、
万能チューリングマシンと呼ばれる、他のチューリングマシンを模倣することのできるチューリングマシンが存在する。

ただし、マシンの符号化やテープ自体の符号化について述べておく必要がある。

## マシンやの符号化
ここでは \(\Sigma_U = \{(, ), 1, ",", -, \#, L, R, C\}\) など豊富な記号を用いて符号化するが、
符号自体は二種類でも同じようなことが可能になる。

チューリングマシン \(M= (\Sigma, Q, q_{\text{init}}, Q_{\text{fin}}, \delta)\) に対して、

- \(\Sigma\) が有限集合であることから、適当な全単射 \(\Sigma \to \{0, 1 \ldots M_n\}\) をとっておく（ \(M_n\) は自然数） 
    - ただし、 \(\mathbb{B}\) が \(0\) に対応しているものとする
- また、 \(Q\) も有限集合であることから、適当な全単射 \(Q \to \{1 \ldots M_m\}\) をとっておく（ \(M_m\) は自然数）
- これにより、チューリングマシンを自然数の有限集合の上で定義されているものとみなす

こうして得られたチューリングマシンをさらに、\({\Sigma_U}^*\) 上へ次のように符号化する。
ここで、 \(n \in \mathbb{N}\) は \(n\) 個 \(1\) を並べることで \({\Sigma_U}^*\) へ符号化しておくものとする

- まず \(\Sigma, Q\) と \(q_{\text{init}}\) については自然に \({\Sigma_U}^*\) の元とみなせる。
- \(Q_{\text{fin}}\) は元を "," 区切りで並べる。
- \(\delta\) は各エントリ \((a,b,c,d,e)\) に対して \((a,b,c,d,e)\) をそのまま並べるようにし、各エントリは "," で区切る。
- これらを "#" 区切りで並べる。

こうしてマシンの符号化が得られた。

マシンが動いているテープの符号化については、基本的には "," 区切りで自然数を並べ、左右無限に空白が並んでいる地帯は途中から符号化せずに "#" ではさむ。
また、ヘッドのさしている位置だけは "," の他に "-" ではさむことにする
例えば、 \(...000143[2]51000...\) は \(...\#1,1111,111,-11-,11111,1\#\) のように符号化する。
ただし、都合上、 \(...\#,,,1,1111,111,-11-,11111,1,,,\#\) （はしに \(0\) が好きなだけ並んでいる）もまた符号化としてよい。

このようにすると計算状況が符号化される。

## 万能チューリングマシンの構成
あとやることは、実際に計算状況の符号化から次の計算状況の符号化を導き出すようなマシンの構成だけになる。
具体的な構成は // いつかやる。

# 計算可能な関数の全体とは？
記憶が定かでないのだけれど、確かこの万能チューリングマシンを使うと、
チューリングマシンの計算可能な関数全体がちょうど再帰関数全体に一致することが示せるはず。
上では記号を多量に用いたけど、各記号自体を \(4\) 字の \(\{b,1\}\) に符号化して、万能チューリングマシンの基本動作を「 \(4\) つ記号を読み取る」を中心に考えれば、
マシンの符号化と万能チューリングマシンの構成が \(\{b,1,-\}\) とかでできる。

そのため、ざっくり次の感じでできる？

- 各チューリングマシンを符号化することで、チューリングマシンの計算可能な関数と万能チューリングマシンの計算可能な関数が一致する。
    - この時点で怪しい、チューリングマシンの計算可能性にでてくる符号化と万能チューリングマシンの計算可能性に出てくる符号化が異なるのでは？
- 万能チューリングマシンの動作を再帰関数とかなんか述語をつかって模倣する

まああまり本格的にやらなくていいか。

# abstract non-sense な議論
なお、 A から B への部分関数全体を A -> B と書く。
関数は --> とする。
部分関数に対しても適当に合成 * や定義域を含めた等式 = と定義域を含めない（両者が定義されている範囲では等しい）等式 ~ を考えておく。
計算能力に関する議論は次のようにまとめることができる。
\(\Sigma = \{\mathbb{B}, 0, -\}\) を固定する。
N で自然数全体を表す。

- 再帰関数全体の集合 Rec 
- Rec は N -> N の部分集合であり、包含写像を i とする。
- \(\Sigma\) 上の Tape 全体を Ta とする
- \(\Sigma\) 上のチューリングマシン全体を Tu とする。
- 符号化 s1: N -> Ta と 符号化 s2: Ta -> N がある
- これらについての関係式として s1 * s2 ~ 1, s2 * s1 ~ 1 がある。
- チューリングマシンをテープからテープへの関数とみなす関数 ev: Tu --> Ta -> Ta がある。
- 符号化を通じてテープ状の関数を自然数関数とみなす関数 sign-s1-s2: (Ta -> Ta) -> (N -> N) がある
- 再帰関数のチューリングマシンへの翻訳 comp: Rec --> Tu がある。
- このとき、 sign-s1-s2 * ev * comp = i がなりたつ。

これが、再帰関数がチューリングマシンによってあらわせたという状況の整理である。

また、 universal Turing machine に対しても同様の感じで議論を進めようとすると次のようになる。
- チューリングマシンとテープの符号化 ad-sign: Tu × Ta --> Ta
- universal Turing machine U: Tu がある。
- これらは次を満たす... ev U (ad-sign (M, t)) = ev M t が任意の M: Tu と t: Ta で成り立つ。
- 計算可能な関数の全体とは Im (sign-s1-s2 * ev) のことである。
- "universal Turing machine" に対応する再帰関数 u がある
- すなわち次が成り立つ... i u = sign-s1-s2 (ev U)
