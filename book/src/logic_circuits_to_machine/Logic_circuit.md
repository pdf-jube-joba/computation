# 論理回路
## ざっくりとした説明と動く見本
オンかオフのみがある信号を考える（ \{0,1\} と思ってよい）。
ゲートと呼ばれる基本要素は、複数の信号を入力に、一つの出力を決定する。
論理回路はこのゲートの入力と出力を組み合わせて信号を伝番させて計算を行う。

## 形式的な定義
論理回路の本を読んでも数学的構造として何かといった議論はあまりないか、あったとしてもチューリング完全にはならないような定式化をしていることが多い（有限なゲートの組み合わせだとダメそう）。
一方で、論理回路の本を読めば数学的構造として定義するなら何を定めればいいかは容易に察せる（と思う）。
ただ、定義しようとするとめんどくさいし間違いは多そう。
ここではその定式化を使うことにする。

ただし、普通のやり方で論理回路から作ろうとすると問題があるため、
ここでは問題点を回避するために煩雑なことをたくさんやる必要が出てきた。
主な問題点は、チューリング同値のとこで話していた「計算モデルは各計算に対応するものが有限な方法で記述できる必要がある」ことと、チューリング完全性の両立である。
おそらく論理回路を考える人はチューリング同値にする必要がないので、こんなことを議論しないでいいようになっているに違いない。

> **Note**
> 計算の複雑性の理論では、boolean circuit と呼ばれるものがかなり形式的に定義されている。
> nand2tetrisでは、dffをゲートの一つに入れて考えているが、あまり形式的に意味論を与える本ではない。
> 読み取れてないだけかもしれないが。

> **definition**
> ラベルと呼ばれる、グラフの頂点に貼り付ける用の集合を次のように（複数に分けて）定義する。
> - 論理ゲートのラベルと呼ばれる集合 \(G\) を \(\{\text{AND}, \text{OR}, \text{NOT}\}\) とする。
> - 分岐を行うためのラベルとして \(B = \{\text{BR}\}\) を用意する。
> - 入力ラベル \(I\) を \(\{\text{IN}(n) \mid n \in \mathbb{N}\}\) とする。
> - 出力ラベル \(O\) を \(\{\text{OUT}(n) \mid n \in \mathbb{N}\}\) とする。
> - ラベルの全体\(L\) は \(G \cup B \cup I \cup O\) とする。

論理回路はグラフに上のラベリングをするものになる。
ただし、制限をつける必要があるため、そのための語彙として次のものを導入しておく。
- 復習もかねて、グラフとは集合 \(V\) （頂点の集合と呼ばれる）と \(V \times V\) の部分集合 \(E\) （辺の集合と呼ばれる）の組 \((V,E)\) のことである。以降はなんも調べずに作った記号なので信用してはいけない。
- \(v \in V\) に対して、
    - \(v\) へ入っていく \(e \in E\) 全体を \(\rightarrow v\) とし、
    - \(v\) から出ていく \(e \in E\) 全体を \(\leftarrow v\) とする。
- \(v \in V\) に対して、
    - \(v^\prime\) から \(v\) へ入っていく辺が存在する \(v ^\prime\) の集合を \(\cdot \rightarrow v\) とし、
    - \(v\) から \(v^\prime\) へ入っていく辺が存在する \(v ^\prime\) の集合を \(\cdot \leftarrow v\) とする。
- また、 \(v\) と \(v^\prime\) に対して \(v \rightarrow v^\prime\) で \(v\) から \(v^\prime\) への頂点が存在することを表す。

> **definition**
> 論理回路とは有向グラフ \((V,E)\) と \(l\): \(V \to L\) の組であって次の条件を満たすものとする。
> - \(l v = \text{AND}\) なら \(\# (\rightarrow v) = 2\) かつ \(\# (\leftarrow v) = 1\)
> - \(l v = \text{OR}\) なら \(\# (\rightarrow v) = 2\) かつ \(\# (\leftarrow v) = 1\)
> - \(l v = \text{NOT}\) なら \(\# (\rightarrow v) = 1\) かつ \(\# (\leftarrow v) = 1\)
> - \(l v = \text{BR}\) なら \(\# (\rightarrow v) = 1\)
> - \(l v = \text{IN} n\) なら \(\# (\rightarrow v) = 0\) かつ \(\# (\leftarrow v) = 1\)
> - \(l v = \text{OUT} n\) なら \(\# (\rightarrow v) = 1\) かつ \(\# (\leftarrow v) = 0\)
> - \(\{ n \in \mathbb{N} \mid l v = \text{In} n\}\) はある自然数 \(k\) によりちょうど \(\{0 .. k\}\) とあらわされる。
> - \(\{ n \in \mathbb{N} \mid l v = \text{Out} n\}\) はある自然数 \(k\) によりちょうど \(\{0 .. k\}\) とあらわされる。

論理回路 \((V,E,l)\) に対して \(\text{In}(V,E,f) = \text{Im} f \cap I\) 、 \(\text{Out}(V,E,f) = \text{Im} f \cap O\) とする。

> **Note**
> ふつう論理回路といえば、頂点や辺の数が有限な論理回路のことでよいはずだ。
> しかしこう定めると明らかにチューリング同値にはならない（メモリに対応する部分が有限になるから）
> 一方で、単に可算無限な論理回路を考えると、
> こんどはチューリングマシンでエミュレートができないぐらいの計算能力をもってしまう。
> ちょうどいいモデルをずっと探していたが見つからなかったので、
> 頑張ってチューリング同値になるように定義しつつ、
> 同値になることは証明しない方針で行こうと思う（よくないけど）。
> 候補を 2 個考えた。
> どっちがいいかはわからないのでとりあえず 2 個載せておく。

上の Note でも書いたようにこのままだと論理回路のちょうどチューリング同値な subset を見つけることができていないので、**後で** これを修正する。
その前に、論理回路自体をどのように動かすかを記述しておく。

> **definition**
> 論理回路 \((V,E,l)\) を固定する。
> 論理回路 \((V,E,l)\) の状態とは、 \(V \to \{0,1\}\) のことである。

論理回路の状態は得られたので、あとはどのように動くか（どのように状態が変化していくか）を述べればよい。

> **definition**
> 論理回路 \((V,E,l)\) の状態 \(s\) が与えられたとき、 \(s\) の次の状態 \(s^\prime\) を次のように定める。
> - \(l v = \text{AND}\) のとき
>   - \(0 \in \{s v^\prime \mid v^\prime \rightarrow v\}\) なら \(s^\prime v = 0\)
>   - そうでないなら \(s^\prime v = 1\)
> - \(l v = \text{OR}\) のとき
>   - \(1 \in \{s v^\prime \mid v^\prime \rightarrow v\}\) なら \(s^\prime v = 1\)
>   - そうでないなら \(s^\prime v = 0\)
> - \(l v = \text{NOT}\) のとき
>   - \(\{s v^\prime \mid v^\prime \rightarrow v\}\) は一元集合のはずなので \(\{x\}\) と表せる。
>   これを用いて \(s^\prime v = 1 - x\)
> - \(l v = \text{BR}\) のとき
>   - \(\{s v^\prime \mid v^\prime \rightarrow v\}\) は一元集合のはずなので \(\{x\}\) と表せる。
>   これを用いて \(s^\prime v = x\)
> - \(l v = \text{OUT} \) のとき
>   - \(\{s v^\prime \mid v^\prime \rightarrow v\}\) は一元集合のはずなので \(\{x\}\) と表せる。
>   これを用いて \(s^\prime v = x\)
> - \(l v = \text{In} \) のとき \(s ^\prime v = s v\)

> **definition**
> 論理回路の状態 \(s\) が安定状態であるとは次の状態が同じ \(s\) になることをいう。

> **Note**
> この安定という語は学術用語として使うかわからないけど、授業では（形式的には定義されなかったが）使った。
> フリップフロップなどで定常状態云々みたいな感じ。

このままでもいいのだが、開始状態がいい感じに定まっているとよい。
重要な点として、入力がすべて \(0\) ならなにも動かないとよい。
> **definition**
> 論理回路 \((V,E,l)\) の開始状態とは、状態 \(s\) であって安定していて \(s \{\text{In}(V,E,l)\} = \{0\}\) となっているもののこと。

以降では論理回路といったら開始状態も加えて \(4\) つの組 \((V,E,l,s)\) のように書くことにする。
論理回路 \(G_i = (V_i, E_i, l_i, s_i)\) があるとき、この入出力をつなぎ合わせることで \(1\) つの論理回路 \(G_1 \# G_2\) が構成できる。
// TODO もっとちゃんと書く。

### 1 つめの定義（計算可能な関数を使ってしまう場合）
> **definition**
> 計算可能な論理回路列とは次の組である。
> - 単調増加する自然数列 \(\{i_n\}_{n \in \mathbb{N}}\) 
> - 各 \(n\) に対して有限な論理回路 \((\{0..i_n\}, E_n, l_n, s_n)\) 
> - 次の条件が保たれる。
>   - 自然に定まる \((\{0..i_n\}, E_n) \to (\{0..i_{n+1}\}, E_{n+1})\) は忠実充満な埋め込みである
>   - ラベリングや状態が \(\{0..i_n\} \to \{0..i_{n+1}\}\) なる埋め込みと compatible である。
> - \(\subset_n E_n\) は計算可能である。

この計算可能な論理回路列からは明らかに極限として \(1\) つの論理回路が得られる。
計算可能な論理回路列の極限として得られる論理回路が計算可能な論理回路である。

あるいは同じことだが、次のような定義もできる。。
> **definition**
> 論理回路 \((\mathbb{N}, E, l, i)\) の組であって次のことを満たす論理回路が計算可能な論理回路である。
> ある計算可能な \(f\): \(\mathbb{N} \to \mathbb{N} \times \mathbb{N}\) であって次を満たすものがある。
>   - \(E = \text{Im} f\)
>   - \(f\) は次のようにして定義される全順序を保つ: \((i,j) \leq (k, l) \leftrightarrow \text{max} \{i,j\} \leq \text{max} \{k,l\}\)

> **Note**
> こうしておけば、チューリングマシンでエミュレートできるはず。
> 開始状態が安定していて、辺が計算可能関数で記述できて、となっているので、
> テープに最初の情報を載せておいて、必要になったら、論理回路を拡張していけばよいので計算できる。

### 2 つめの定義（ iteration を繰り返して得られる論理回路）
> **definition**
> 繰り返し論理回路とは次の帰納的な構成により得られるものをさす。
> - 有限論理回路は繰り返し論理回路である。
> - 繰り返し論理回路の（計算可能な）結合は繰り返し論理回路である。
> - 繰り返し回路 \(G\) に対して \(G \# G \# G \# \cdots \) は繰り返し回路である。
