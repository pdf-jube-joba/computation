# 論理回路
## ざっくりとした説明と動く見本
オフとオンのみがある信号を考える（ \(\{0,1\}\) と思ってよい）。
ゲートと呼ばれる基本要素は、複数の信号を入力に、一つの出力を決定する。
論理回路はこのゲートの入力と出力を組み合わせて信号を伝番させて計算を行う。
ゲートは、 AND, OR, NOT などがある。
ちゃんと知りたい場合は調べればすぐに出る。
ここではそれに加えていくつゲートを追加しているので注意。

下の例は、 XOR と呼ばれる機能を実現する論理回路の例。
"IN0" とかをクリックするとオン（緑）とオフ（赤）が切り替えられる。
`Step` を押せば次の状態に移る。

<script type="module">
    import { load, LogicCircuitViewModel } from "../assets/generated/logic_circuit/logic_circuit_glue.js";
    import { TextAreaSource, TextDefinedSource, UserControls } from "../assets/utils.js";
    await load();

    let res1 = await fetch("../assets/component/logic_circuit_to_machine/XOR.txt");
    let txt1 = await res1.text();

    let code_input1 = new TextDefinedSource(txt1);
    let control1 = new UserControls("control1");

    let default_placement = new Map();
    default_placement.set("B0", { x: 0, y: 70 });
    default_placement.set("B1", { x: 200, y: 70 });
    default_placement.set("D0", { x: 0, y: 140 });
    default_placement.set("N0", { x: 100, y: 140 });
    default_placement.set("D1", { x: 200, y: 140 });
    default_placement.set("N1", { x: 300, y: 140 });
    default_placement.set("A0", { x: 100, y: 210 });
    default_placement.set("A1", { x: 300, y: 210 });
    default_placement.set("O", { x: 200, y: 280 });

    let view1 = new LogicCircuitViewModel(code_input1, control1, "view1", default_placement);
</script>

<div id="machine1">
    <div id="control1"></div>
    <div id="view1"></div>
</div>

## 形式的な定義
論理回路の本を読んでも数学的構造として何かといった議論はあまりないか、あったとしてもチューリング完全にはならないような定式化をしていることが多い（有限なゲートの組み合わせだとダメそう）。
一方で、論理回路の本を読めば数学的構造として定義するなら何を定めればいいかは容易に察せる（と思う）。
ただ、定義しようとするとめんどくさいし間違いは多そう。
ここではその定式化を使うことにする。

ただし、普通のやり方で論理回路から作ろうとすると問題があるため、
ここでは問題点を回避するために煩雑なことをたくさんやる必要が出てきた。
主な問題点は、チューリング同値のとこで話していた「計算モデルは各計算に対応するものが有限な方法で記述できる必要がある」ことと、チューリング完全性の両立である。
おそらく論理回路を考える人はチューリング同値にする必要がないので、こんなことを議論しないでいいようになっているに違いない。

あと、普通の論理回路の議論では現実に立ち向かっているので、遅延とか構成部品の特性（電圧とかの応答？）を考える必要があり、どう配置するかも問題になってくる。
（グラフを平面に配置する。）

> **Note**
> 計算の複雑性の理論では、boolean circuit と呼ばれるものがかなり形式的に定義されている。
> nand2tetrisでは、dffをゲートの一つに入れて考えているが、あまり形式的に意味論を与える本ではない。
> 読み取れてないだけかもしれないが。

> **definition**
> ラベルと呼ばれる、グラフの頂点に貼り付ける用の集合を次のように（複数に分けて）定義する。
> - 論理ゲートのラベルと呼ばれる集合 \(G\) を \(\{\text{AND}, \text{OR}, \text{NOT}\}\) とする。
> - 分岐を行うためのラベルとして \(B = \{\text{BR}\}\) を用意する。
> - 定数を出力するラベル \(C\) を \(\{\text{C0}, \text{C1}\}\) とする。
> - 入力を捨てるためのラベルとして \(E = \{\text{END}\}\) と定める。 
> - 入力ラベル \(I\) を \(\{\text{IN}(n) \mid n \in \mathbb{N}\}\) とする。
> - 出力ラベル \(O\) を \(\{\text{OUT}(n) \mid n \in \mathbb{N}\}\) とする。
> - ラベルの全体\(L\) は \(G \cup B \cup C \cup E \cup I \cup O\) とする。

論理回路はグラフに上のラベリングをするものになる。
ただし、制限をつける必要があるため、そのための語彙として次のものを導入しておく。
- 復習もかねて、グラフとは集合 \(V\) （頂点の集合と呼ばれる）と \(V \times V\) の部分集合 \(E\) （辺の集合と呼ばれる）の組 \((V,E)\) のことである。
    - 多重辺を入れなくてよいのでこっちを採用した。
    - 以降はなんも調べずに作った記号なので信用してはいけない。
- \(v, v' \in V\) に対して、 \(v \rightarrow v'\) を \((v, v')\) と思うことにする。
    - \(v \rightarrow v' \in E\) とか書く。
- \(\cdot \rightarrow v\): \(V\) の部分集合 := \(\{v' \in V \mid v' \rightarrow v \in E\}\)
- \(v \rightarrow \cdot\): \(V\) の部分集合 := \(\{v' \in V \mid v \rightarrow v' \in E\}\)

> **definition**
> 論理回路とは有向グラフ \((V,E)\) と \(l\): \(V \to L\) の組であって、 \(v \in V\) ごとに次の条件を満たすものとする。

| \(l(v)\) | \(\# (\cdot \rightarrow v)\) | \(\# (v \rightarrow \cdot)\) |
|---------|---------|--------|
| AND     | \(2\) | \(1\) |
| OR      | \(2\) | \(1\) |
| NOT     | \(1\) | \(1\) |
| C0      | \(0\) | \(1\) |
| C1      | \(0\) | \(1\) |
| BR      | \(1\) | \(2\) |
| IN      | \(0\) | \(1\) |
| OUT     | \(1\) | \(0\) |

> ただし、
> - \(\{ n \in \mathbb{N} \mid l v = \text{In} n\}\) はある自然数 \(k\) によりちょうど \(\{0 .. k\}\) とあらわされるか、自然数全体に一致する。
> - \(\{ n \in \mathbb{N} \mid l v = \text{Out} n\}\) はある自然数 \(k\) によりちょうど \(\{0 .. k\}\) とあらわされるか、自然数全体に一致する。

論理回路 \((V,E,l)\) に対して \(\text{In}(V,E,f) = \text{Im} f \cap I\) 、 \(\text{Out}(V,E,f) = \text{Im} f \cap O\) とする。

> **Note**
> ふつう論理回路といえば、頂点や辺の数が有限な論理回路のことでよいはずだ。
> しかしこう定めると明らかにチューリング同値にはならない（メモリに対応する部分が有限になるから）
> 一方で、単に可算無限な論理回路を考えると、
> こんどはチューリングマシンでエミュレートができないぐらいの計算能力をもってしまう。
> ちょうどいいモデルをずっと探していたが見つからなかったので、
> 頑張ってチューリング同値になるように定義しつつ、
> 同値になることは証明しない方針で行こうと思う（よくないけど）。
> 候補を 2 個考えた。
> どっちがいいかはわからないのでとりあえず 2 個載せておく。

上の Note でも書いたようにこのままだと論理回路のちょうどチューリング同値な subset を見つけることができていないので、**後で** これを修正する。
その前に、論理回路自体をどのように動かすかを記述しておく。

> **definition**
> 論理回路 \((V,E,l)\) を固定する。
> 論理回路 \((V,E,l)\) の状態とは、 \(V \to \{0,1\}\) のことである。

論理回路の状態は得られたので、あとはどのように動くか（どのように状態が変化していくか）を述べればよい。

> **definition**
> 論理回路 \((V,E,l)\) の状態 \(s\) が与えられたとき、 \(s\) の次の状態 \(s^\prime\) を次のように定める。
> - \(l v = \text{AND}\) のとき
>   - \(0 \in \{s v^\prime \mid v^\prime \rightarrow v\}\) なら \(s^\prime v = 0\)
>   - そうでないなら \(s^\prime v = 1\)
> - \(l v = \text{OR}\) のとき
>   - \(1 \in \{s v^\prime \mid v^\prime \rightarrow v\}\) なら \(s^\prime v = 1\)
>   - そうでないなら \(s^\prime v = 0\)
> - \(l v = \text{NOT}\) のとき
>   - \(\{s v^\prime \mid v^\prime \rightarrow v\}\) は一元集合のはずなので \(\{x\}\) と表せる。
>   これを用いて \(s^\prime v = 1 - x\)
> - \(l v = \text{BR}\) のとき
>   - \(\{s v^\prime \mid v^\prime \rightarrow v\}\) は一元集合のはずなので \(\{x\}\) と表せる。
>   これを用いて \(s^\prime v = x\)
> - \(l v = \text{OUT} \) のとき
>   - \(\{s v^\prime \mid v^\prime \rightarrow v\}\) は一元集合のはずなので \(\{x\}\) と表せる。
>   これを用いて \(s^\prime v = x\)
> - \(l v = \text{In} \) のとき \(s ^\prime v = s v\)

> **definition**
> 論理回路の状態 \(s\) が安定状態であるとは次の状態が同じ \(s\) になることをいう。

> **Note**
> この安定という語は学術用語として使うかわからないけど、授業では（形式的には定義されなかったが）使った。
> フリップフロップなどで定常状態云々みたいな感じ。

このままでもいいのだが、開始状態がいい感じに定まっているとよい。
重要な点として、入力がすべて \(0\) ならなにも動かないとよい。
> **definition**
> 論理回路 \((V,E,l)\) の開始状態とは、状態 \(s\) であって安定していて \(s \{\text{In}(V,E,l)\} = \{0\}\) となっているもののこと。

以降では論理回路といったら開始状態も加えて \(4\) つの組 \((V,E,l,s)\) のように書くことにする。
論理回路 \(G_i = (V_i, E_i, l_i, s_i)\) があるとき、この入出力をつなぎ合わせることで \(1\) つの論理回路 \(G_1 \# G_2\) が構成できる。
// TODO もっとちゃんと書く。

### 1 つめの定義（計算可能な関数を使ってしまう場合）
> **definition**
> 計算可能な論理回路列とは次の組である。
> - 単調増加する自然数列 \(\{i_n\}_{n \in \mathbb{N}}\) 
> - 各 \(n\) に対して有限な論理回路 \((\{0..i_n\}, E_n, l_n, s_n)\) 
> - 次の条件が保たれる。
>   - 自然に定まる \((\{0..i_n\}, E_n) \to (\{0..i_{n+1}\}, E_{n+1})\) は忠実充満な埋め込みである
>   - ラベリングや状態が \(\{0..i_n\} \to \{0..i_{n+1}\}\) なる埋め込みと compatible である。
> - \(\subset_n E_n\) は計算可能である。

この計算可能な論理回路列からは明らかに極限として \(1\) つの論理回路が得られる。
計算可能な論理回路列の極限として得られる論理回路が計算可能な論理回路である。

あるいは同じことだが、次のような定義もできる。
> **definition**
> 論理回路 \((\mathbb{N}, E, l, i)\) の組であって次のことを満たす論理回路が計算可能な論理回路である。
> ある計算可能な \(f\): \(\mathbb{N} \to \mathbb{N} \times \mathbb{N}\) であって次を満たすものがある。
>   - \(E = \text{Im} f\)
>   - \(f\) は次のようにして定義される全順序を保つ: \((i,j) \leq (k, l) \leftrightarrow \text{max} \{i,j\} \leq \text{max} \{k,l\}\)

> **Note**
> こうしておけば、チューリングマシンでエミュレートできるはず。
> 開始状態が安定していて、辺が計算可能関数で記述できて、となっているので、
> テープに最初の情報を載せておいて、必要になったら、論理回路を拡張していけばよいので計算できる。
> これって要は、"プログラム"で書ける論理回路のことになる。

### 2 つめの定義（ iteration を繰り返して得られる論理回路）
はじめに論理回路の結合を定義しておく。
> **definition**
> 論理回路 \((V, E, l)\) に対して、 \(v, v' \in V\) であって \(l(v) \in \text{IN}, l(v') \in \text{OUT}\) となっているものに対して、次のように定義される論理回路を \((v, v')\) の結合と呼ぶことにする。
> - \((V - \{v, v'\}, E \cup \{v'_2 \rightarrow v_2\} - \{v \rightarrow v_2, v'_2 \rightarrow v'\}, l\mid_{\text{restriction}})\)

> **definition**
> 繰り返し論理回路とは次の帰納的な構成により得られるものをさす。
> - 有限論理回路は繰り返し論理回路である。
> - 繰り返し論理回路に結合を行ったものも繰り返し論理回路である。
> - 繰り返し論理回路の直和は繰り返し論理回路である。
>   - これは、  \((V, E, l), (V', E', l')\) から \((V \sqcup v', E \sqcup E', \text{mix}(l, l'))\) みたいな操作
>   - 注意点として、入出力のラベルの番号付けはちゃんとやらないといけない。
> - 繰り返し回路 \((V, E, l)\) に対して、 \((v^{\text{in}}_i, v^{\text{in}}_j)\) を使って、 \((V \times \Nat, \{(v, i) \rightarrow (v', i) \mid v \rightarrow v' \in E\}, l)\) に対して結合を行う。
