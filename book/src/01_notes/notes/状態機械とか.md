# abstract non-sense な議論
結局この話は、統一的にモデルを書こうとする話（このリポジトリ）では必要になったので書いておく。
（もともと Coq で書こうとして抽象的すぎる抽象化がいやでやめたのに...）

A から B への部分関数全体を A -> B と書く。
関数は --> とする。
部分関数に対しても適当に合成 * や定義域を含めた等式 = と定義域を含めない（両者が定義されている範囲では等しい）等式 ~ を考えておく。

## 計算モデルは何をしている？
計算能力に関する議論は次のようにまとめることができる。
\(\Sigma = \{\mathbb{B}, 0, -\}\) を固定する。
N で自然数全体を表す。

- 再帰関数全体の集合 Rec 
- Rec は N -> N の部分集合であり、包含写像を i とする。
- \(\Sigma\) 上の Tape 全体を Ta とする
- \(\Sigma\) 上のチューリングマシン全体を Tu とする。
- 符号化 s1: N -> Ta と 符号化 s2: Ta -> N がある
- これらについての関係式として s1 * s2 ~ 1, s2 * s1 ~ 1 がある。
- チューリングマシンをテープからテープへの関数とみなす関数 ev: Tu --> Ta -> Ta がある。
- 符号化を通じてテープ状の関数を自然数関数とみなす関数 sign-s1-s2: (Ta -> Ta) -> (N -> N) がある
- 再帰関数のチューリングマシンへの翻訳 comp: Rec --> Tu がある。
- このとき、 sign-s1-s2 * ev * comp = i がなりたつ。

これが、再帰関数がチューリングマシンによってあらわせたという状況の整理である。

また、 universal Turing machine に対しても同様の感じで議論を進めようとすると次のようになる。
- チューリングマシンとテープの符号化 ad-sign: Tu × Ta --> Ta
- universal Turing machine U: Tu がある。
- これらは次を満たす... ev U (ad-sign (M, t)) = ev M t が任意の M: Tu と t: Ta で成り立つ。
- 計算可能な関数の全体とは Im (sign-s1-s2 * ev) のことである。
- "universal Turing machine" に対応する再帰関数 u がある
- すなわち次が成り立つ... i u = sign-s1-s2 (ev U)

この議論をすごい単純に考えるとこんな感じ
- \((C: \SET, I: \SET, O: \SET, f: C \times I \partfunction O)\) の組が計算モデル。
- 2つの計算モデル \(M_i\) に対して、 \(m: C_0 \to C_1, s: I_0 \to I_1, s': O_1 \partfunction O_0\) が翻訳になる
  - ここで、 \(s\) が \(C_0\) ごとには決まっていないというのが、"問題ごとに符号化を変更しない"ことになる。
- 翻訳の well-def は \(s' \comp f_1 (m(c), s(i)) = f_0(c, i)\) だけ
- universal なものの存在は、 \(k: C \times I \to I\) に対して、 \(f(u, k(c, i)) = f(c, i)\)

符号化が余計な仕事をしていないかが気になる。
例えば、実質的に符号化が Turing 完全な仕事をしていることもありうる。
それをどう弾くべきかがわからない。

というか、定義がやっぱり虚無過ぎる。

## Mealy machine / Moore machine
Mealy machine と Moore machine は automaton っぽいが、重要そうなので載せておく。
回路とか "system" っぽいものの一般論に使われる。
ただし、外部の入力がリアルタイムに入ってくる想定に近い。

- \((S: \SET, I: \SET, O: \SET, \delta: S \times I \to S \times O)\) が Mealy machine （ただし \(S\) に有限であることを課す。）
- \((S: \SET, I: \SET, O: \SET, \delta_0: S \times I \to S, \delta: S \to O)\) が Moore machine （ただし \(S\) に有限であることを課す。）
- あと、初期状態と終了状態を定義しておいた方がいい。

\(S\) の有限性の仮定を外してしまえば一般のシステムが記述できる。

これもあまりにも抽象的な定義だ。

## universal coalgebra
[universal coalgebra: a theory of systems] を呼んだが、ちょっと関係なかったかも。
確かに Mealy machine を含めたいろんな系が議論できるのはわかるが、"計算"の話とはちょっとずれてる？
主に、系の発展と bisimulation の話を一般論でやるための設定っぽい。

## T diagram
Wiki [Tombstone diagram] を見ると、必要最低限ぐらいの物が書かれている。
Tombstone diagram と呼ばれる、言語処理系の系譜を説明するために使われるような図式のこと。

I diagram
  : interpreter は、メタ言語 Lm で書かれたプログラムが言語 L の処理系になる。
  これを I の形にして、下側に Lm、 上側に L を書く。

T diagram
  : compiler は、 メタ言語 Lm で書かれたプログラムが言語 L1 を入力として受け取って言語 L2 を出力する。
  これを T の形にして、下側に Lm、左に L1、右にL2を書く。

これの別の表し方として、 J diagram というのが
[digram for composing compilers] とかで紹介されている。

プログラムが言語を受け取る（？）の部分は、符号化を考えないといけないが、
全部自然数と思えるからいいだろうと思っている？

## Turing category
[Intro Turing cat] これはかなり考えていることに近い気がする。
- eval と encoding がある（ application ができる）
- universal なものが作れる
- partial である

が重要？

## ブラムの公理
計算模型に寄らない形で計算複雑性を定義できるらしい。
後で調べる。

## その他メモ
可算であるか判定できることはどの議論にも必要に思える。
なので、初めから自然数の上で議論していると考えたほうがいい？

## reference
mdbook のビルドでは見えないが、以下がちゃんとしたリンク

[universal coalgebra]: https://ir.cwi.nl/pub/48/0048D.pdf
[Intro Turing cat]: https://www.sciencedirect.com/science/article/pii/S0168007208000948
[digram for composing compilers]: https://johnwickerson.github.io/papers/jdiagrams.pdf
[Tombstone diagram]: https://en.wikipedia.org/wiki/Tombstone_diagram
