み アセンブリ言語
いわゆるアセンブリ言語を紹介する。
アセンブリ言語はだいたい機械語と命令が1-1に対応している言語のことだが、
そのまま01の列とかを書くのはめんどくさいから、 mnemonic と呼ばれるような記述で楽に書く。
これに加えていろいろな機能がある。
1. 制御のブロックにラベルを付ける
2. 定数やいくつかの場所に名前を付ける

とかね。
ラベルはあとから番号を振ったりして、代入する。
"どこに何を置くか"だけ名前が付けられるようにした言語と思っていい。

アセンブリ言語がどう動くかを単体で定めることはなくて、どう機械語に翻訳されるかだけが議論されていることが多い。

<div data-model="symbolic_asm">
</div>

## データとコードについて
どこに書くか迷ったけどここに書いておく。
ちょうど内容がそんな感じの話をせざるを得なくなったから。

計算モデルはデータとコードを分けるかどうかで大きく分けることができて、
ラムダ計算、ノイマン型のCPU（を中心としたメモリとかも含めた機械）はデータとコードを分けず、コード単体で動かすことができる。
データを処理させるときはデータをコードに埋め込むことになるから、入力を受け取って出力を返すコードを使って、データを埋め込むことになる。
例えばラムダ計算なら、コード \(M\) とデータ \(N\) に対して \((M N)\) という"コード"を生成して、コード単体を実行していることになる。
ノイマン型も同じで、命令の列とデータの列を連結してから実行する。
（なぜなら、両方ともビット列なので、並べることができる。）

別にそれ自体が悪いわけではないけれど、人間の扱う側ではコードとデータを分けたほうが嬉しいので、
"プログラミング"を行う側のモデルとしてはコードとデータを分けることにすることが多い。
アセンブリ言語もその典型というか、 `.text` というセクションにコードをおいて `.data` というセクションにデータを置くなど、
人間が書いて人間が読んで、その意図を長く保つための工夫がある。
問題は、アセンブリ言語自体にはデータとコードの分かれ目がある（ように扱いたい）のに、それがコンパイルされる先にはその差がないこと。
例：ローダーはデータとしてのコードを読み、データとして書き換え、それをコードとして読みだしたりする。

1. `01110010` というデータを読み出す。（実はそれは命令としては「あるアドレスにあるメモリを読み出す」操作である。）
2. `01110011` に変更する。（命令と解釈した場合の読み出す先のアドレスを書き換えている。）
3. 次の命令で修正した命令が入っているところにジャンプする。

そうなると、アセンブリ言語の側では意味が分からないように思えるただの数値だが、コードとしては意味を持つことがある。
`.data` というセクションに置かれているデータに対して、それをコードとして読む、みたいなことが行えてしまう。
他の例としては、dynamic dispatch とかは、データの中で「コード上のどこに飛ぶか」をポインタ（値）として持っている。
それはコードの側でどこに関数が配置されるかを事前に知ってないとできない。
その場合に、それはアセンブリ言語単体での意味論として正しいのか？
もちろん、最終的に機械語になるのだからそもそも意味のない問いと思うこともできて、
基本はそう考えるほうが筋がいい。
（整合性があるから。）

ただ、そういう"職人芸"じみたことは混乱につながるので、
アセンブリ言語単体での意味論としては、 `.data` と `.code` の越境を許さない形で定義して、
そこを超える場合には未定義としてしまうのが、素直な気がする。
なので、以降は、 **アセンブラ単体ではコードとデータがきちんと分かれている**ものとして、動作を議論したい。

### もうちょっと考える
universal Turing machine にせよ、 VM にせよ、
データ領域にあるものをコードと思うことで動作するような機械が作れてしまうので、
コードとデータを分けたところで、上のような問題はつねに発生しうる。
いわゆる reflection （データの側から実行時の動作をある程度自由に制御する仕組み）は、
Turing 完全な計算モデルならできる。
（と人間から解釈できるような動作を行うコードが存在するはず。）

ただし、普通はある種の `as_code(data)` みたいな関数を経由したり、
内部のコード内の制御がデータの側に明かされていることが前提（としてコード側に伝えられている）となっている。
これを踏まえて、逆に、機械語の側に対してもっとデータとコードを分けて考えるようなモデルを与えることもできる。

それがハーバード型とか modified なハーバード型になっている。
例を挙げる（出展を思い出せない...Wikipedia?）
- メモリを2つ用意して、一方にコードがありもう一方にデータがある。以下は variant
  1. コードの側では、 load, store はデータの側に対してしか行えない、ジャンプ先は変更ができない
    - ただしこの場合でも、「データの側で 0 か 1 か → コードの側のジャンプ先の変更」ができるので、
      どんなコードが入っているかを知っていれば、実質的な reflection ができる。
      というか、これぐらいはできないと使えない。
  2. ジャンプ先をデータの側から指定するなど。
  3. load, store をコードに対して行う、2つのメモリの swap があるなど。
  4. コード側のメモリとデータ側のメモリが連結している（これがノイマン型）。
    - ただし、現代のものだと無造作にジャンプできたりはなくて、
      メモリの領域は実行可能かどうか、
      現在の動作モードでは読み取り可能かどうかなどが設定されていることがある。
- そもそも別の主となる機械に従属しているので、外部からコードとデータを与えられて、基本的な分岐以外はできない機械もある。
  - GPU とか？
