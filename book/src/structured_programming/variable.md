アセンブリを追っていると、レジスタが有限個になっていることで、
今から使おうとしているレジスタに、後から使う必要のある値が入っているという問題が起きる。
その場合、レジスタ（に入っている値）を一度メモリに退避させて、
必要に応じてまたレジスタに戻す必要がある。
これを自動的に判定してアセンブリを挿入することができれば、
レジスタそれ自身への値の出し入れを記述しなくてもよくなる。
つまり、 load/store を忘れて、変数が無限で goto を使って分岐するような言語を考えれば、
そこからアセンブリ言語への変換が定義できるということ。

ただし、複雑な式はいけない。
算術としてできるのは、2変数の演算まででのことが多い。
いわゆる 3-address 形式と呼ばれる形式の言語になる。

- 計算用の式
  - これはアセンブラのことを考えてそれに容易に翻訳できるような拡張を入れてもいい。
- 制御用の式
- ラベル付けのブロック

これらに加えて、
- SSA 形式への制限：すべての変数は代入が一度だけされるように制限する
- \(\phi\) 関数という、ブロックの合流地点において、各ブロックの変数を引き継ぐためのマーク
  例えば `BB1: {y1 = 2; Goto BB}, BB2: {y2 = 3; Goto BB}` みたいな2つの異なるブロックに対して、
  `BB: {y = phi(y1, y2)}` のように書くことで、
  `y` は「BB1 を通った場合には `y1` から来ていて、 BB2 を通った場合には `y2` からくる」ことを表す。
  数学的な関数というよりも、意味を明示するために書いている。

などを入れることが多い。

> [!Note]
> ここらへんは実用の世界がかなり近いので、
> "理論側"でさえも形式的証明に使えるようなものは、実用を考えた、込み入ったものが多い。
> 教育用、あるいは簡単な PoC としての実装さえも複雑になっていて、
> （計算モデルといえばチューリングマシンみたいな）共通認識として使えるようなものは見つからなかった。
> 特に必要を感じないのかもしれない？
> - メモリそれ自体の線形性がなくなった場合は、この後で話す関数とスタックフレームの話で困ることになる。
>   単純に言うと、変数 `x` の"次の変数"（や前の変数）みたいな概念が使える言語でないと、これからの議論で困る。
>   これは単に `new(set: Set<Var>)` があること以上の意味論を持っているものの、
>   メモリの境界を超えるような操作はしてはいけないはずなので、
>   "少なくとも"線形で無限に並んだメモリがある、ことぐらいは議論の中で必要そう。
> - また、"変数が無限"の意味も難しくて、各コードごとに有限の変数しか現れないのであれば、
>   はじめから静的に `.data` にラベルで割り当てたのを implicit にレジスタを経由するのと変わらない。
>   なぜそうしないのかというと、そもそも"そうする"ことはコンパイルのやり方の問題（意味論が保たれるか）だから。
>   ここら辺が難しいところで、3-address 形式もアセンブリと同じように、機械語にどう翻訳されるかがその意味の中核をなすわけで、
>   それ単体で何を保証しているか、共通の見解として提示できるような formal で simple な言語はない。
> - AI によると他にも、 SSA 形式に限らないで意味論を考えることはできる
>   （それはそう、環境を変数から数字へのマップにすればいい）ものの、
>   その場合だとあまりうまくいかないらしい。
>   どうしてうまくいかないのかはごにょごにょ言ってるがよくわからなかった。
>   確かに SSA 形式でないものまで含めるとコンパイルが壊れるようなことをやることになるが、
>   「hogehoge として定義される言語のうち SSA 形式のもの」に限ればコンパイルが意味を保っているとしてもおかしくはないはずなのに？
>   なんかうまくいかないことは学習されているようなので、インターネットではおそらく、なんかうまくいかないこと自体は共有されているみたい。
> 結局のところ、実用が近すぎるのでこういうことを考えるのは無駄みたい。
> 「どうコンパイルされるか」だけが正義のような感じ。
