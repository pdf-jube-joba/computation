# Turing machine（ざっくり）
Turing machineの構成要素はだいたい以下の通り

- **記号**が書かれたテープ（ちょうど前にあるテープしか読み書きができない。）
- **状態**を持つ制御部
- プログラム（とか遷移表と言われる）：「状態・記号」から次の「状態・記号・テープの動かし方」への対応一覧

このプログラムに従ってテープと制御部を動かしていくことで、テープを書き換えながら動作する。
最終的に終了状態と呼ばれる状態に行きついたら動作は終了であり、
どんなテープを入力すると停止するのか、その時のテープの状態はどうか、
といった部分を計算とみなすことができる。

## 具体例

テープにある `a` を全部 `b` に書き換える例。
テープの最後には `c` をつけること。
<div data-model="turing_machine">
<script type="text/plain" class="default-code">
start
goal
a,start,b,start,R
b,start,b,start,R
c,start,c,goal,C
</script>
<script type="text/plain" class="default-ainput">
-|a|b,a,b,b,c
</script>
</div>

テープにある `a` と `b` の"仕分け"を行う例。

<div data-model="turing_machine">
<script type="text/plain" class="default-code">
s
g
a,s,a,s,R
-,s,-,g,C
b,s,b,k,R
b,k,b,k,R
-,k,-,g,C
a,k,b,b,L
b,b,a,r,L
b,r,b,r,L
a,r,a,r,L
x,r,x,s,R
</script>
<script type="text/plain" class="default-ainput">
x|b|a,a,b
</script>
</div>

## Turing machine（ちゃんとした解説）
ここ以降は読まなくても大丈夫。

> [!WARNING]
> Turing machineの定義は複数あり、本によって異なる。
> 標準的なものはないようなので、都合のいい感じで定義している。

## 定義
### Turing machineの定義
空白記号（ blank symbol ）と呼ばれるものを固定し、 \(\mathbb{B}\) と書く。
この元は後述する「記号の集合」に必ず含まれることを仮定し、Turing machineの定義を通して固定をしておく。

> [!Note]
> この空白記号もTuring machineの定義に含める議論も多いが、にもかかわらず、
> 異なるマシンで空白記号が共有されているかのような議論が多かったため、ここでは固定した。
> 空白記号を含めて定義する場合、基点付き集合として記号の集合を定義するのが良いかもしれない。
> ここでは hyphen (`-`) を使っている。

Turing machine
  : 次の組をTuring machineと言う。
    - \(\Sigma\) : \(\mathbb{B}\) を含む有限集合...この集合の元を記号という
    - \(Q\): 有限集合...この集合の元を状態という
    - \(q_{\text{init}}\): \(Q\) の元...これを開始状態という
    - \(Q_{\text{fin}}\): \(Q\) の部分集合...この集合の元を終了状態という
    - \(\delta\): \((Q - Q_{\text{fin}}) \times \Sigma\) から \(Q \times \Sigma \times \{L,R,C\}\) への部分関数

Turing machine \(M\) に対して、 \(\Sigma_M\) や \(M.\Sigma\) など添え字やドットを付けることで、
\(M\) の構成要素のうち対応する \(\Sigma\) をあらわすことにする。
また、Turing machineの定義のうち特に \(\Sigma\) を固定して話すことが多いから、
与えられた \(\Sigma\) に対して \(\Sigma_M = \Sigma\) となるTuring machine \(M\) を、
\(\Sigma\) 上のTuring machineと呼ぶことにする。

ここで、 \(\delta\) は部分関数であるから、（集合を用いた定義を考えると） \((Q - Q_{\text{fin}}) \times \Sigma \times Q \times \Sigma \times \{L,R,C\}\) の部分集合とみなせる。
この関数の元 \((q, \sigma, q^\prime, \sigma^\prime, D)\) をエントリと呼ぶことにする。
（このエントリという語はあまり気にしなくてもいい。）

> [!NOTE]
> Turing machineの他の定義には次のものがある。
> - \(\Sigma\) の部分集合としてさらに \(\Gamma\) なる"入力記号の集合"を指定する
> - \(\delta\) の定義を全域関数とする。これについては後にフォローを行う。
> - \(\delta\) の値域を \(Q \times \Sigma \times \{L,R\}\) とする。
> - \(\delta\) の値域を \(Q \times \Sigma \sqcup Q \times \{L,R,C\}\) とする。
> - 終了状態の集合 \(Q_{\text{fin}}\)ではなく終了状態 \(q_{\text{fin}} \in Q\) を指定する。

### Turing machineが操作するものの定義
今、集合 \(\Sigma\) に対して（ \(\Sigma\) 上の）テープと呼ばれるものを考える。
このテープとは、各"セル"に \(\Sigma\) の元が格納されたものが左右無限に並んだもののことを言う。
ただし、テープの中の有限個のセルを除いて、セルは基本的に（先ほど固定した空白記号） \(\mathbb{B}\) が入っているものとする。
さらに、このテープには制御部と呼ばれるものがついていて、セルのうちの一つを指し示している。
あまり使わないかもしれないが、 \(\Sigma\) 上のテープ全体を \(\text{Tape}(\Sigma)\) と書くことにする。

このテープに対しては次のような操作を行うことができる。
- テープ \(T\) に対して、制御部を一つ右（ resp. 左）に動かしたテープ： \(\text{R}(T)\) （ resp. \(\text{L}(T)\) ）
- また、 テープ \(T\) に対して、 \(\text{C}(T) = T\) とする。
- テープ \(T\) に対して、制御部の指し示すセルの中身の記号を取り出す... \(\text{Head}(T)\)
- テープ \(T\) と \(s \in \Sigma\) に対して、制御部の指し示すセルの中身を \(s\) で書き換えたテープ： \(\text{Write} (T, s)\)

> [!NOTE]
> テープの数学的な定義はちょっとめんどくさい。テープ（というかヘッド？）の状態は置いといて、定義は2つぐらいある。
> 
> テープ
>  : 整数の集合 \(\mathbb{Z}\) から \(\Sigma\) への写像であって、有限個を除いて \(\mathbb{B}\) に移る写像
>  : 自然数 \(i\) と、 \(\{1 \ldots i\}\) から \(\Sigma\) への写像であって、
>     先ほどと同様の条件を満たすものと、 \(l \in \{1 \ldots i\}\) の組のこと。
>  : \(\Sigma\) 上の語と呼ばれる \(\Sigma\) の元を"有限個並べた"集合 \(\Sigma^*\) を許容すれば、
>    テープは単に \(\Sigma^* \times \Sigma^*\) や \(\Sigma^* \Sigma \times \Sigma^*\) と書ける。
>    ただし、"有限個並べる"の定義はプリミティブな操作とみなされるか、
>     自然数 \(l\) と \(\{1 \ldots l\} \to \Sigma\) の組として定義されるだろう。
> 
> なんにせよ、ここで重要なのは \(\text{R}(T)\) ・ \(\text{L}(T)\) ・ \(\text{Head}(T)\) ・ \(\text{Write}(T, s)\) といった操作を行えることである。
> また、テープの定義には \(\Sigma\) が表れるのだが、テープと書いている本が多い。
> ここでは、 \(\Sigma\) 上の、と書くことでテープの定義に言及できるようにした。
> ただしい用語かはわからない。

が、これではテープの指定の仕方がわからないので、とりあえず次の取り組みをしておく。

テープの定義
  : \(l, r \in \Sigma^*\) と \(h \in \Sigma\) に対して、 \((l,h,r)\) を \(\text{Tape}(\Sigma)\) の元とみなす。
 具体的には、制御部の指示している記号が \(h\) であり、制御部より左には \(l\) 、 制御部より右には \(r\) が並んでいるものとする。

> [!NOTE]
> 状態 \(Q\) の元を保持しているということはテープの定義は \(\Sigma\) と \(Q\) を固定するごとに定まるはずである。
> そのため、テープの定義自体を \(\Sigma, Q\) を固定してから述べるものも多いが、ここではテープを \(\Sigma\) 上で定義した。
> 制御部は \(Q\) の元を一つ保持しているというのは、 \(\text{Tape}(\Sigma) \times Q\) の元を選んでいるという風に考えればよい。

こうして得られる \(\text{Tape}\Sigma \times Q\) の元を計算状況と呼ぶ。

### Turing machineの計算の定義
Turing machineの計算は遷移関数を用いてテープと状態を変化させていくことで得られる。
Turing machine \(M = (\Sigma, Q, q_{\text{init}}, Q_{\text{fin}}, \delta)\) に対して次のように定義する。

計算動作
  : 計算状況 \((T, q)\) に対して、\((q, \text{Head} T, q^\prime, \sigma, D) \in \delta\) となるエントリがある場合、計算動作と呼び \((T,q) \rightarrow_{M} (D \text{Write}(T, \sigma), q^\prime)\) のように書く。
  そのようなエントリがない場合、停止していると言い、 \(q \in Q_{\text{fin}}\) のとき正常停止と呼ぶ。

計算列
  : 計算動作の列 \((T_0, q_0) \rightarrow_{M} (T_1, q_1) \rightarrow_{M} \cdots \rightarrow_{M} (T_n, q_n)\) を計算列と呼ぶ。

計算過程
  : テープ \(T\) に対して \(P_0 = (T, q_{\text{fin}})\) から始まる計算列 \(P_0 \rightarrow_{M} \cdots \rightarrow_{M} P_n\) であって \(P_n\) が停止しているものを計算過程と呼ぶ。

計算結果
  : テープ \(T\) と \(T^\prime\) に対して、ある \(q\) であって \(P_n = (q, T^\prime)\) が最後となる計算過程が存在するとき、 \(T \rightarrow^{M} T^\prime\) と書く。

> [!NOTE]
> Turing machineの定義に \(Q_{\text{fin}}\) という集合を採用したことにより、我々の定義の場合は単に計算が（正常に）停止しているかといった情報だけではなく、どのような状態で停止しているのかという情報もまた含まれていることに注意したい。
> 特に、Turing machineをテープを受け取りテープを返す関数としてだけ見ているよりは情報が簡単に得られる。
> ただし、終了状態が一つしかないような定義を採用した場合も、テープに終了状態に対応するものを書き込むことで、以降行うことに対しても我々の定義と同様の操作を行うことができる。

今、考えたい"計算"があったとして、次のように形式化を定めることでTuring machineによる計算ととらえることができる。
- 考えたい計算を形式化する：例えば集合 \(A\) から \(B\) への部分関数 \(f\) とする。
- 二つの集合 \(A\) と \(B\) に対して、適切な符号の集合 \(\Sigma\) と符号化を選ぶ：\(A\) や \(B\) の \(\Sigma\) 上のテープ全体への埋め込み（\(\bar{a}\) や \(\bar{b}\) と書く）を固定する。
- よい条件を満たすTuring machine \(M\) を構成する：条件とは、
    - \(a \in A\) に対して、\(f(a)\) が存在すれば、 \(\bar{a}\) の正常停止する計算過程が存在して最後の計算状況が \((\bar{f(b)}, \_)\) になっている。
    - \(a \in A\) に対して \(\bar{a}\) の正常停止する計算過程が存在して最後の計算状況が \((T, \_)\) になっていれば、 \(f(a)\) が存在して \(T = \bar{f(a)}\) が成り立つ。

> [!NOTE]
> 符号化を選ぶ必要があることに注意する。
> 記号の集合 \(\Sigma\) は有限集合であると決まっているので、例えば自然数上の関数をエミュレートするには \(\Sigma\) として単に自然数全体をとることはできない。
> また、符号化のとり方自体も複数ありうることがある。例えば、自然数の \(\Sigma = \{\mathbb{B}, 0,1\}\) 上のテープへの符号化として、二進数表示を行う以外に \(0\) を使わずに \(1\) を自然数の大きさ分だけなられる方法も考えられる。

> [!NOTE]
> 計算可能な自然数の全体って明らかに符号化のとり方による。
> 符号化のとり方自体を"計算可能"なものに限りたいわけだが、その議論は初めにとった符号化のとり方によってしまう。
> 腑に落ちない。

## 具体例
二進数で書かれた自然数に1を足すマシンを作ってみる。
考え方としては、下の桁から順に見て行けばよい。
\(q_{\text{init}}\) から左に行き、 \(0\) が出てきたら \(1\) に書き換えて終わる。
\(1\) が出てきたら \(0\) に書き換えて、さらに繰り上がりモードを継続する。

遷移関数は次のようにすればいい（もっと簡単にできるはず）。

| key_sign | key_state | value_sign | value_state | value_direction |
| --- | --- | --- | --- | --- |
| - | start | - | add_1| L |
| 0| add_0| 0| add_0| L |
| 1| add_0| 1| add_0| L |
| 0| add_1| 1| add_0| L |
| 1| add_1| 0| add_1| L |
| -| add_0| -| end| C |
| -| add_1| 1| write| L |
|  | write| -| end| L |

ここでは記号や状態、初期状態と終了状態を省略した。
