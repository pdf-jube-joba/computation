# ラムダ計算 （ざっくり）
ラムダ計算とは、ラムダ項と呼ばれる式と、その間の"変換"と呼ばれる関係式により、式をどんどん変形していく計算モデルである。
**多分今紹介している中では一番わかりにくい。**

- ラムダ項は変数・関数の宣言・関数の関数適用、みたいなもののみを使って作られる
    - 変数は `x` とか `y` とか
    - 関数の宣言はちょっと独特で、 `f(x) = x + 1` を `\x. x` のように書く。
    - 関数の適用も独特で、 `f(5)` を `(f 5)` のように書く。
- ラムダ項は現れる変数を（その束縛に注意しつつ）適当に変更してよい
    - `f(x) = x + 1` と `f(y) = y + 1` が同じ関数であるのと同じように、 `\x. x` と `\y. y` は同じとみなす。
- ラムダ項はその中に関数の適用があると、変数の置き換えを行う。
    - `f(x) = x + 1` としたとき `f(5)` はまず書き換えると `5 + 1` になるのと同じように、 `(\x. x + 1) 5` はまず書き換えると `5 + 1` になる。

説明にはわかりやすく `+` を使ったけれど、
ふつうのラムダ項には実際はそういうものがない。

## 具体例
わかりやすい例が全然ないので、とりあえずいろいろ動く例を載せた。

<script type="module">
    import { load, LambdaCalculusViewModel } from "../assets/generated/lambda_calculus/lambda_calculus_glue.js";
    import { TextAreaSource, TextDefinedSource, UserControls } from "../assets/utils.js";
    await load();

    let code_input1 = new TextAreaSource("user_defined1");
    let control1 = new UserControls("control1");

    let view1 = new LambdaCalculusViewModel(code_input1, control1, "view1");

    let code_input2 = new TextAreaSource("user_defined2");
    let control2 = new UserControls("control2");

    let view2 = new LambdaCalculusViewModel(code_input2, control2, "view2");
</script>

まずは、 `f(x) = x` に対して、 `f(y)` を計算する例

<div id="machine1">
    <div id="control1"></div>
    <textarea id="user_defined1" rows="1" cols="20"> (\x.x) y </textarea>
    <div id="view1">
    </div>
</div>

次はちょっと長い。
自然数を次のようにラムダ項にうつす。
- \(0\) は `\s. \z. z`
- \(1\) は `\s. \z. (s z)`
- \(2\) は `\s. \z. (s (s z))`
- \(3\) は `\s. \z. (s (s (s z)))`
こう考えると、 \(s(n) = n \mapsto n + 1\) を表す関数は、 `\x.\y.\z. (y ((x y) z))` とすればいい。
\(s(2)\) はそうすると次のようになる。

<div id="machine2">
    <div id="control2"></div>
    <textarea id="user_defined2" rows="1" cols="60"> (\ x y z. (y ((x y) z))) (\s z. (s (s z))) </textarea>
    <div id="view2">
    </div>
</div>

ちゃんと \(3\) に対応する表現が得られている。

## 定義
### 変数について
まず変数の集合 \(\Lambda\) を適当に固定しておく。
これは無限集合ならほとんどなんでもよいが、プログラミングや形式的な扱いの上では

- 2 つの変数が等しいかどうかが簡単に決定できる（ \(\Lambda \times \Lambda \to \text{bool}\) みたいな写像が構成できる）
-  有限な部分集合に対してはその部分集合に含まれないような変数をとることができる（ \(\mathop{\text{finite subset of}} \Lambda \to \Lambda\)）

とよい。

### ラムダ項の定義
> **definition**
> ラムダ項は以下の帰納的な定義で得られるもの（のみ）をいう。
> - 変数はラムダ項である。
> - 変数 \(x\) と ラムダ項 \(M\) に対して \(\lambda x.M\) はラムダ項である。このラムダ項をラムダ抽象という。
>     - ラムダ抽象は変数 \(x\) で引数を指定し、 \(M\) で関数の中身を述べている。
> - \(2\) つのラムダ項 \(M_1, M_2\) に対して \((M_1 M_2)\) はラムダ項である。このラムダ項を関数適用という。
    - 関数適用は関数を引数で呼び出すものに対応する。 関数 \(f(x)\) に \(1\) を代入するのを \(f(1)\) のように書いたりするが、ラムダ計算の中では"関数" \(M_1\) を引数 \(M_2\) で呼び出すのを \((M_1 M_2)\) と書く（ \(M_1(M_2)\) ではない）。

ラムダ抽象は、関数に名前を付けることなく関数を述べることができるので、プログラミング言語の中でも似たようなものが使われることがある。
例えば、 \(x\) を受け取って \(x + 1\) を返す関数を \(\lambda x.x+1\) のように書いたりする人もいるが、これもまたラムダ抽象と呼ばれたりもする。 
また、関数適用も同じようにラムダ計算以外の文脈で記法が使われることがある。

| 流儀 | 関数 | 関数の呼び出し |
| --- | --- | --- |
| 数学でよく書く | \(f(x)\) | \(f(1)\) |
| ラムダ項っぽい | \(f\) | \((f 1)\) や \(f 1\) |

ラムダ項を latex で書くのはめんどくさいので、ここでは `x` や `\x.M` や `M N` のように書くこともある。
\\ が \(\lambda\) に対応している。
また、 \(M_1 \cdots M_n\) は \(( \cdots ((M_1 M_2) M_3) \cdots M_n)\) の略記とする。
さらに、 \(\lambda x_1 \cdots x_n. M\) は \(\lambda x_1. \lambda x_2. \cdots \lambda x_n.M\) の略記とする。
また、特に断りがなければ、小文字は変数、大文字はラムダ項を表す。

> **definition**
> ラムダ項の部分項を次のように定義する。
> - \(M\) 自身は \(M\) の部分項である。
> - \(M\) の部分項は \(\lambda x.M\) の部分項である。
> - \(M\) の部分項は \((M N)\) の部分項である。
> - \(N\) の部分項は \((M N)\) の部分項である。

### ラムダ項の中に現れる変数の気持ち
ラムダ項を実際に計算する前に変数について注意しておかないといけない。
ここではわかりやすさのためにラムダ項を適当に拡張し \(M + N\) とか数字もラムダ項に含まれている感じで扱う。
あくまでも具体例のため。

`\x.x` はラムダ抽象によって関数を定義しているが、中にあらわれる `x` はラムダ抽象によってちょうど **束縛** されて、代入時にちょうど置き換えられる。
例えば、 `\x.x` に `1` を代入すると `1` になり、 `\x.x+3` に `1` を代入すると `1+3` になる。
一方で `\x.y` は `x` が束縛されていて `y` は束縛されていない。
だから、 `\x.y` に `1` を代入すると `y` になり `\x.y+3` に `1` を代入すると `y+3` になる。
この具体例で出てきた `y` はラムダ抽象によって縛られていない **自由** な変数である。

関数を述べるときにどの変数を用いて定義するかは関数の本質ではなく、束縛する変数を一斉に付け替えることができる。
ちょうど \(\sum_i a_i = \sum_j a_j\) のように変数を付け替えるように、 `\x.x` と `\y.y` を同一視したい。
一方で、付け替えの中で余計な変数が束縛されないようにしなければいけない。
\(\sum_i \sum_j a_{i,j} = \sum_i \sum_i a_{i,i}\) のような変形をしてはいけないのと同様の理屈である。
`\x.M` に `N` を代入しようとするとき、 `N` に含まれる自由な変数が誤って束縛されることがないように `\x.M` 自身の束縛を取り替えて `\y.M'` のようにしなければいけない。
また、 \((y \\y.y)\) のように、 \(y\) が自由な出現をしていながら別のところで束縛された状態で出現することもある。
このような項は \(2\) つの \(y\) は異なるものとして認識される必要がある。

### ラムダ項の中にあらわれる変数と、変数の付け替え

> **definition**
> ラムダ項 \(M\) の自由変数全体 \(\text{FV}(M)\)を次のように定義する
> - 変数 \(x\) に対して \(\text{FV}(x) = \{x\}\)
> - 変数 \(x\) とラムダ項 \(M\) に対して \(\text{FV}(\lambda x.M) = \text{FV}(M) - \{x\}\)
> - ラムダ項 \(M, N\) に対して \(\text{FV}(M N) = \text{FV}(M) \cup \text{FV}(N)\)
> 
> ラムダ項の束縛変数全体 \(\text{BV}(M)\) を次のように定義する。
> - 変数 \(x\) に対して \(\text{BV}(x) = \emptyset\)
> - 変数 \(x\) とラムダ項 \(M\) に対して \(\text{BV}(\lambda x.M) = \{x\} \cup \text{BV}(M)\)
> - ラムダ項 \(M, N\) に対して \(\text{BV}(M N) = \text{BV}(M) \cup \text{BV}(N)\)

変数の置き換えについて議論するため、 **ラムダ計算で必要とされる代入とは異なる**代入を定義する。
非常に単純な代入の仕方を次で定義する。
ラムダ項 \(M\) に対して、自由に出現する変数 \(x\) の \(N\) への置き換え \(\text{subst}(M,x,N)\) を次で定義する。
- 変数 \(x\) に対して、 \(\text{subst}(x,x,N) = N\)
- \(x\) とは異なる変数 \(y\) に対して \(\text{subst}(y,x,N) = y\)
- 変数 \(x\) とラムダ項 \(M\) に対して \(\text{subst}(\lambda x.M, x,N) = \lambda x.M\)
- \(x\) とは異なる変数 \(y\) とラムダ項 \(M\) に対して \(\text{subst}(\lambda y.M, x,N) = \lambda y.\text{subst}(M,x,N)\)
- \(2\) つのラムダ項 \(M_1, M_2\) に対して \(\text{subst}((M_1 M_2), x, N) = (\text{subst}(M_1, x, N) \text{subst}(M_2, x, N))\)

この代入を用いて、アルファ同値と呼ばれる「束縛変数の違いを無視して同一視する」同値関係 \(\sim_{\alpha}\) を次のように定義する。

> **definition**
> ラムダ項の間の関係 \(\sim_{\alpha}\) を次のように定義する。 
> - 変数 \(y\) とラムダ項 \(M\) に対して \(y \notin \text{FV}(M)\) ならば、 \(\lambda x. M \sim_{\alpha} \lambda y.\text{subst}(M, x, y)\) である。
> - \(M \sim_{\alpha} M\) 
> - \(M_1 \sim_{\alpha} M_2\) なら \(\lambda x. M_1 \sim_{\alpha} \lambda x. M_2\)
> - \(M_1 \sim_{\alpha} M_2\) かつ \(N_1 \sim_{\alpha} N_2\) なら \((M_1 N_1) \sim_{\alpha} (M_2 N_2)\)

だいたい次のようなことが成り立つはず。
- アルファ同値は同値関係
- アルファ同値は自由変数を保つ
- どのラムダ項も束縛変数と自由変数が被らないような別のラムダ項にアルファ同値である

また、変数を気にせずに式全体がどのような木構造をしているかを考えると、アルファ同値はこの木構造も保っている。
すなわち、ラムダ抽象や適用、変数がどこででてくるかは完全に一致しているはずである。

ラムダ項をアルファ同値なラムダ項に変更することをアルファ変換という。
ただし、ラムダ項に対してアルファ変換な別のラムダ項が一意に定まっているわけではないので、
アルファ変換は関数ではなく関係である。

### 代入とベータ変換
以上をもとに**通常の**代入とベータ変換と呼ばれる写像が定義できる。

> **definition**
> ラムダ項 \(M\) に対して、変数 \(x\) とラムダ項 \(N\) による代入 \(M[x:=N]\) を次のように定義する。
> - 変数 \(x\) に対しては \(x[x:=N] = N\)
> - \(x\) と異なる変数 \(y\) に対しては \(y[x:=N] = y\)
> - ラムダ抽象 \(\lambda x. M\) に対しては \((\lambda x.M)[x:=N] = \lambda x.M\)
> - \(x\) と異なる変数 \(y\) に対しては
>   - \(y \notin \text{FV}(N)\) ならば \((\lambda y.M)[x:=N] = \lambda y.(M[x:=N])\)
>   - そうでない場合には、 \(\lambda y.M\) とアルファ同値で条件を満たす \(M^\prime\) を用いて \(M^\prime[x:=N]\) とする

この代入が正常に定義されているか確認する必要がある。
- アルファ同値で条件を見た満たす \(M^\prime\) のとりかたに"よらず"に定まるか、
    - これは up to アルファ同値でしか定まっていない
- 関数が正常に値を計算できるか
    - ふつうは関数 \(f\) を定義する際に \(f\) を用いた場合、 \(f\) がしっかり定義されているか確かめる必要がある。
        - 例えば、 「\(f\) を \(f(x)^2 = 1\), \(f(1)=1\) を満たす連続写像により定義する」といったとき \(f\) が一意に存在するかを議論する必要がある
        - 他にも 「 \(f\) を \(f(0) = 0\), \(f(x+1) = f(x) + 1\) で定義する」など定義部分で \(f\) を用いている場合、計算が実際にすべての値で進むことを示す必要がある。
    - 今回の場合はラムダ項の構造に対する帰納法に見えて、一番最後の項が必ず停止するかどうかがわからない。
        - つまり、 \(M_1[x:=N]\) を計算するために \(M_2[x:=N]\) を計算するために...と、アルファ同値で置き換えると問題が大きくなり続けて値の計算ができないかもしれない。
    - これを回避するためには、アルファ同値がラムダ項の木構造を保っていることを考える必要があるが、それを考えるとほぼ自明

ラムダ項の部分項であって \((\lambda x. M N)\) の形をした部分項を \(\beta\) 簡約基と言う。
\(\beta\) 簡約基 \((\lambda x. M N)\) を \(M[x:=N]\) で置き換えることを \(\beta\) 簡約という。
\(\beta\) 簡約基は \(1\) つのラムダ項の中に複数ありえるため、 \(\beta\) 簡約は一意に定まらない。
\(\beta\) 簡約を定式化すると次のようになる。

> **definition**
> ラムダ項の間の関係 \(\to_{\beta}\) を次で定める。
> - \((\lambda x. M N) \to_{\beta} M[x:=N]\)
> - \(M \to_{\beta} N\) なら \(\lambda x. M \to_{\beta} \lambda x. N\)
> - \(M_1 \to_{\beta} M_2\) なら \((M_1 N) \to_{\beta} (M_2 N)\)
> - \(N_1 \to_{\beta} N_2\) なら \((M N_1) \to_{\beta} (M N_2)\)

> **definition**
> ラムダ項の間の関係 \(\twoheadrightarrow_{\beta}\) を \(\to_{\beta}\) の推移閉包として定める。
> ラムダ項が \(\beta\) 簡約基を持たないとき、正規形と呼ぶ。
> ラムダ項が自由変数を持たないとき閉項と呼ぶ。

正規形を持たないラムダ項が存在するが、正規形を持つかどうかは決定することができない。

> **theorem**
> 合流性：ラムダ項 \(M\) に対して \(M \to_{\beta} M_1\) かつ \(M \to_{\beta} M_2\) ならば、ある \(N\) が存在して \(M_1 \twoheadrightarrow_{\beta} N\) かつ \(M_2 \twoheadrightarrow_{\beta} N\) が成り立つ。
> 正規形の一意性：ラムダ項 \(M\) に対して \(M \twoheadrightarrow_{\beta} N\) であって正規形であるような \(N\) はアルファ同値を除いて一意である。

ラムダ項 \(M\) からどのように \(\beta\) 簡約基を選んで簡約するかを決定する方法を、評価戦略と呼ぶ。
どんな評価戦略をとっても、正規形が得られればそれは他の評価戦略で得られた結果と一致している。
この意味で、簡約結果は一意である。
ラムダ項を簡約してゆき正規形を得ようとすることが、ここでは計算と呼べる。

評価戦略をいくつか紹介する

> **definition**
> 最左最外戦略： \(\beta\) 簡約基のうち、最も外にあり最も左にあるものを評価する戦略をこう呼ぶ。
> 値呼び、名前呼び： \(\beta\) 簡約基 \(((\lambda x. M) N)\) に対して引数 \(N\) を評価しきってから簡約を行うことを値呼びという。名前呼びは引数 \(N\) を評価する前にこの簡約基を簡約する。
> parallel reduction：これは評価戦略というか \(\beta\) 簡約関係をより扱いやすくするために作られた新たな関係のことになるが、だいたい引数とかを同時に一回ずつ簡約するもののことを言う。

最左最外簡約は非常に強い性質を持つ。

> **theorem**
> ラムダ項が正規形を持つなら最左最外簡約を繰り返すことで到達できる。

## Church encoding とラムダ計算による自然数関数の計算可能性
ラムダ計算もまた帰納関数の計算を"埋め込む"ことができる。
帰納関数の埋め込み方は複数あるが、ここでは代表的な Church encoding を用いる。
自然数の埋め込みと、帰納関数の埋め込みを定義する。

### Church encoding

> **definition**
> - 自然数のラムダ項への対応を \(n \mapsto \lambda f. \lambda z. f^{n} x\) により定義する。
> - `true = \x y. x`
> - `false = \x y. y`
> - `succ = \ x y z. y(x y z)`
> - `pred = \x y z. x(\ p q. q(p y))(\ v. z)(\ v.v)`
> - `iszero = \x. x (\y. false) true)`
> - `if = \x y z. x y z`
> - \(\text{proj}^n_i = \lambda x_1, \ldots , x_n. x_i\)
> - \(\text{comp}^n_m = \lambda g f_1, \ldots f_n. \lambda x_1, \ldots x_m. g (f_1 x_1 cdots x_m) \cdots (f_n x_1 \cdots x_m\)\)

これでゼロ関数、後者関数、射影関数、合成関数については定義できたと思ってよい。

これ以上の部分については次の不動点に関する議論が必要になる。

### 不動点コンビネータと再帰関数
再帰関数とは、その関数の定義に自分自身が用いられているもののことを言う。
例えば、階乗 \(\text{fact}\) の定義は次のように書ける
- \(\text{fact} 0 = 1\)
- \(\text{fact} (n + 1) = (n + 1) * \text{fact} n\)

\(2\) 番目のケースにおいて自分自身を用いて定義していることがわかる。
このような関数を定義するうえで重要なこととして、「実際にすべての値で必ず関数値が定まっているか」を確かめる必要がある。
例えば、次の関数は再帰的に定義されているように思えるが、本当に関数になっているかは証明の余地がある。
- \(\text{f} 1 = 1\)
- \(\text{f} 2n = n\)
- \(\text{f} n = \text{f} (3n + 1)\)

再帰関数は帰納法とかかわりが深く、計算機科学ではよくあらわれる。
自然数関数のうち、原始帰納関数と呼ばれる関数の定義の仕方があったことを思い返そう。
また、 \(\mu\) 再帰関数というのもあった。

再帰関数をラムダ計算に表すには工夫が必要である。

> **definition**
> \(\mathbf{Y}\) コンビネータと呼ばれるラムダ式を次で定義する。 
> \(\mathbf{Y} = \lambda f. (\lambda x. f(x x)) (\lambda x. f(x x))\)

> **theorem**
> 任意のラムダ式 \(M\) に対して \(\mathbf{Y} M = M (\mathbf{Y} M)\) が成り立つ。
> 任意のラムダ式 \(M\) に対して \(H = \mathbf{Y} \lambda h x_1 , \ldots x_n. M\) とおくと \(H = \lambda x_1, \ldots x_n. M[h := H]\) が成り立つ。

これを用いると再帰関数が簡単に書ける。
\(2\) つめを用いて以降は単に \(H = \lambda x_1, \ldots x_n. M[h := H]\) のような式で定義を行う。

このコンビネータは不動点コンビネータと呼ばれる。
その理由は、"関数" \(M\) に対して "値" \(v = \mathbf{Y} M\) は不動点になっている（ \(M v = v\) をみたす）からである。
すなわち、 \(\mathbf{Y}\) は関数の不動点を計算し返している関数である。

再帰関数の残りの部分を定義してしまう。

> **definition**
> - ラムダ式 \(f, g\) に対して \(H = \lambda x_0, x_1, \ldots x_n. \text{if} (\text{iszero} x_0) (f x_1 \cdots x_n) (g (H (\text{pred} x_0) x_1 \cdots x_n) (\text{pred} x_0) x_1 \cdots x_n) \)
> - ラムダ式 \(f\) に対して \(H = \lambda x_0, x_1, \ldots x_n. \text{if} (\text{iszero} x_0) x_0 (H (\text{succ} x_0) x_1 \cdots x_n)\)

あとは再帰関数との対応をしっかり与えればよいが、ここまでやれば自明なのでいいか。
こうして再帰関数がラムダ計算で計算可能であることが分かった。
