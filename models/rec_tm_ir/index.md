recursive function -> this IR -> Turing machine

この言語の特徴：
- 変数と制御構造がある。
- 関数は再帰はできない。衛生的なマクロ展開に近い。
- その他に、IR 空の変換後に Turing machine と共有されるテープおよびそれへの操作がある。
  - これは関数呼び出し前後で共有される。
- ただし、変数もテープも事前に与えられた有限集合 \(S\) の値しかとらないものとする。

もうちょっとちゃんと書く。

有限集合 \(S\) が固定されているとする。（空白記号 \(\mathbb{B}\) を含む。）
また、変数の集合 \(V\) は無限でよく、常に \(\mathbb{B}\) で初期化されている。

```
<label> = <string>
<fn-name> = <string>

<stmt> =
  # TM のテープとの interact
  | "LT"            # tape を左に動かす
  | "RT"            # tape を右に動かす
  | "READ" <var>    # head から <var> に値を読み出す。
  | "STOR" <var>    # <var> から head に値を書き込む。
  # 普通のプログラミング
  | <var> ":=" <var>
  | "if" <var> "==" <S> "break" <label>
  | "loop" <label> ":" "{" <stmt>*  "}"
  | "call" <fn-name> "(" <var>* ")"
<function> = "fn" <fn-name> "(" <var>* ")" "{" <stmt>* "}"

# main() と書かれたものを使う。
```

## プログラム状態
- 有限集合 S を固定する。
- 変数集合 V は無限だが、プログラム中で出現する変数は有限。
- 実行状態は (tape, head, env) とする。
  - tape: Z -> S, 有限を除いて \(\mathbb{B}\) に移る
  - head: Z
  - env: V -> S, 有限を除いて \(\mathbb{B}\) に移る

## 基本命令
- LT: head := head - 1
- RT: head := head + 1
- READ v: env[v] := tape[head]
- STOR v: tape[head] := env[v]
- v := w: env[v] := env[w]

## 制御
- loop L { stmt* }:
  - 先頭に制御が到達すると、stmt* を順に実行し、最後まで到達したら再び先頭に戻る。
  - break L に到達すると、対応する loop L を抜けてその直後に制御が移る。
- if v == s break L:
  - env[v] == s のときに限り break L を実行する。
  - 偽の場合は何もせず次の文へ進む。

## 関数と call（マクロ展開としての意味）
- 関数定義は「展開用テンプレート」とみなす。
- call f(a1, ..., an) の意味は以下の**展開規則**により与える。

  1) f の本体中の変数とラベルはすべて新しい名前に α-変換する。
     これにより呼び出し元の変数・ラベルと干渉しない。
  2) 新しい仮引数 p1', ..., pn' について、冒頭に
     p1' := a1; ...; pn' := an
     を挿入する。
  3) その後に α-変換済みの関数本体を続ける。

- 重要: 引数は「共有」されず、呼び出し時に**値がコピー**される。
  呼び出し元の変数への影響は、関数本体が明示的に操作する変数に限られる。
- この展開規則が有限回で終わるために、**再帰呼び出しは禁止**（呼び出しグラフは有向非巡回）とする。

## 共有テープとの関係
- テープへの作用は LT/RT/READ/STOR のみであり、call による暗黙の保存・復元は行わない。

