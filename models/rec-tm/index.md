全体の構成：
recursive function -> IR1 -> IR2 -> Turing machine

<div data-model="recursive_function => rec_tm_ir => rec_tm_ir_jump => turing_machine"></div>

重要な仮定：
Turing machine で扱う用の Tape の記号

- **有限集合 \(S\) が固定されているとする。** （空白記号 \(\mathbb{B}\) を含む。）
- また、変数の集合 \(V\) は無限でよく、常に \(\mathbb{B}\) で初期化されている。

## IR1

この言語の特徴
- 書き込み先はテープと変数の2種類
  - `@` という変数はテープの指しているセルを指す。
  - 変数もテープも事前に与えられた有限集合 \(S\) の値しかとらないものとする。
- 関数は再帰はできない。呼び出しグラフは有向非巡回である。衛生的なマクロ展開に近い。
  - 変数は関数呼び出し前後で共有されない。
  - テープは関数呼び出し前後で共有される。
- `main` と名前の付いた関数を呼び出して始まる。存在しないならエラーになる。

\(\begin{aligned}
\NT{label}    &\defeq \NT{string} \\
\NT{var}      &\defeq \NT{string} \\
\NT{rvalue}   &\defeq \T{@}   \sp | \sp \NT{var} \\
\NT{lvalue}   &\defeq \T{@}   \sp | \sp \NT{var} \sp | \sp S \\

\NT{cond}     &\defeq \T{if} \sp \NT{rvalue} \sp \T{=} \sp \NT{rvalue} \\
\NT{stmt}   &\defeq (\\
  &|\T{LT} |\T{RT}  \\
  &|\NT{;value} \sp \T{:=} \sp \NT{rvalue} \\
  &|\T{jump}      \sp \NT{label}  \sp \NT{cond} \\
  &|\T{break}                     \sp \NT{cond} \\
  &|\T{continue}                  \sp \NT{cond} \\
  &|\T{call}      \sp \NT{name} \\
  &|\T{return}                    \sp \NT{cond} \\
  ) \T{;} \\
\NT{block}    &\defeq \NT{label} \sp \T{:} \NT{stmt}* \\
\NT{function} &\defeq \NT{name} \sp \T{\{} \NT{block} \T{\}} \\

\NT{alphabet-decl} &\defeq \T{alphabet} \sp \T{(} \syntaxmacro{comma-separated}{S} \T{)} \\
\NT{program}    &\defeq \NT{alphabet-decl} \sp \NT{function}+
\end{aligned}\)

プログラム状態
: 実行状態は (tape, head, env) とする。
  - tape: \(\Z \to S\), 有限を除いて \(\mathbb{B}\) に移る
  - head: \(\Z\)
  - env: \(V \to S\), 有限を除いて \(\mathbb{B}\) に移る

基本命令
: 
  - LT: head := head - 1
  - RT: head := head + 1
  - @ := w: tape[head] への w の代入
  - v := w: env[v] への env[w] の代入
  - v := @: env[v] への tape[head] の代入

制御
:
  - jump: 対応するブロックに飛ぶ
  - continue 及び break: 今あるブロックの先頭に飛ぶ、次のブロックの先頭に飛ぶ
  - call/return: 別の関数を呼び出す、今の関数を抜ける

## IR2
これは普通にIR1の関数定義を展開して、 jump はラベルじゃなくて行数にしたもの。

\(\begin{aligned}
\NT{label}    &\defeq \NT{string} \\
\NT{var}      &\defeq \NT{string} \\
\NT{rvalue}   &\defeq \T{@}   \sp | \sp \NT{var} \\
\NT{lvalue}   &\defeq \T{@}   \sp | \sp \NT{var} \sp | S \\

\NT{cond}     &\defeq \T{if} \sp \NT{rvalue} \sp \T{=} \sp \NT{rvalue} \\
\NT{stmt}   &\defeq (\\
  &|\T{LT} |\T{RT}  \\
  &|\NT{lvalue} \sp \T{:=} \sp \NT{rvalue} \\
  &|\T{jump}      \sp \NT{number}  \sp \NT{cond} \\
  ) \T{;} \\

\NT{alphabet-decl} &\defeq \T{alphabet} \sp \T{(} \syntaxmacro{comma-separated}{S} \T{)} \\
\NT{program}  &\defeq \NT{alphabet-decl} \sp \NT{stmt}*
\end{aligned}\)

これの意味は明らかなので書かない。

## IR1 \(\to\) IR2
関数の呼び出しは DAG になっているので、そのまま名前が被らないようにして展開をすればよい。
単純に展開すると名前が被るので、呼び出し**元**の関数の中で名前が一意になるようにする必要がある。

具体例：
```
fn f {
  entry:
    return;
}

fn main {
  entry:
    call f;
  next:
    call f;
}
```

ここで単純に `fn f` だけの情報から得られるブロック列を展開すると、
このようになって同じラベル名が出てきて不適。
そもそも、どこに帰るのかもわからない。
```
main-entry:
  goto f:
f:
  goto f-end:
f-end:
  goto ??:
main-next:
  goto f:
f:
  goto f-end:
f-end:
  goto ??:
main-end:
```

これを踏まえて、ある関数の flatten は次のように行う。
1. 関数内のブロックの処理
    - 関数の実行後に必ず飛ぶ、 return 先の名前を受け取っておく。
    - return 用のブロックを別の用意し、その中には受け取った名前への jump のみを入れる。
    - return/continue/break を具体的なラベル名に置き換えてすべてを jump にする。
    - return については、引数で受け取ったところに jump とする。
    - 呼び出し元が、被らないような名前空間を用意しておく。
2. 他の関数の呼び出しをそれぞれ flatten して、ブロックの列として得る。
    - 他の関数との名前の衝突を避けるためのα変換をすること。
    - 複数の呼び出しがあるケースに対応するため、呼び出し元ラベルと呼び出しの行数を一意性として使う。
3. ブロックを `flat_map` のようにして展開する。

これを `main` に対してやればよい。

こんな感じに変形するべき（呼び出し元ラベルと行数のラベルを入れる）
```
main-entry:
    goto main-entry-0-f
  main-entry-0-f:
    goto main-next
  main-entry-0-f-end:
    goto main-next
main-next:
    goto main-next-0-f
  main-next-0-f:
    goto main-next-0-f-end
  main-next-0-f-end:
    goto main-end
main-end:
```

こうして得られたブロック列は、 `call/return/break/continue` free な IR1 である。
これを変換するのは簡単で、各ラベルを行数に直しておけばよい。

## IR2 \(\to\) TM
最初から \(S\) が与えられているので、
「tape[head] が何であろうと次はこの状態に行く」が「すべての \(S\) を列挙して状態遷移」に変換できる。
あとは基本的には行数と変数環境を状態として encode すればよい。
登場する変数も実際にわかっているので、最初から空白が代入されていると考える。

具体例：
```
0: v := @;
1: w := v;
2: RT;
3: jump 0 if w = @;
```

- \(V' \defeq \{v, w\}\)
- \(Q \defeq \{0..=4\} \times (V' \to S)\)
- \(Q_{\text{accepted}} = \{4\} \times (V' \to S)\)

このもとで、
1. `v := @`     :\(([0, (v \mapsto s_1, w \mapsto s_2)], s) \mapsto ([1, (v \mapsto s  , w \mapsto s_2)], s), C\)
2. `w := v`     :\(([1, (v \mapsto s_1, w \mapsto s_1)], s) \mapsto ([2, (v \mapsto s_1, w \mapsto s  )], s), C\)
3. `RT`         :\(([2, (v \mapsto s_1, w \mapsto s_2)], s) \mapsto ([3, (v \mapsto s_1, w \mapsto s_2)], s), R\)
4. `jump ...`   :
  - \(([3, (v \mapsto s_1, w \mapsto s_2)], s) \mapsto ([0, (v \mapsto s_1, w \mapsto s_2)], s), C\) ... これを \(s_2 = s\) の場合に追加
  - \(([3, (v \mapsto s_1, w \mapsto s_2)], s) \mapsto ([4, (v \mapsto s_1, w \mapsto s_2)], s), C\) ... これを \(s_2 \neq s\) の場合に追加

## 再帰関数 \(\to\) IR1
### テープの符号化と解釈
この節では、チューリングマシンの計算可能な関数を考えるため、自然数の符号化を述べる。
ちゃんと `\,` とかを入れるのがめんどくさいので以降ではそのまま inline block で書く。
以降では、実装に合わせて次のように書く。
- 空白記号： `-`
- 区切り記号： `x`
- フラグ記号： `l`

また、ヘッドのある部分を `a, b, c | d | e, f, g` のように `|` で囲む。

自然数の符号化
: \(n \in \Nat\) に対して、 `l l  ... l l` のように `l` を \(n\) 個並べる。
  これをコードでは `l(n)` と書き、数学側では \(b(n)\) と書く。

自然数の tuple の符号化
: \(k \in \Nat\) と \(p = (n_1, \ldots, n_k) \in \Nat^k\) に対して、
  `- l(n_1) - l(n_2) - ... - l(n_k)` のように並べる。
  これをコード側では `F(p)` と書き、数学側では \(\phi(n)\) と書く。
  また、大文字が inline code の中に登場したときはこのような形式のものを表すとする。
  さらに、これを `x` で挟むことで目印とする。
  逆の操作 \(\psi: \Sigma^ * \to \Nat\) は常にできるわけではないので、
  そのような \(n\) が存在しない場合に備えて、 \(\psi\) の値域を拡張する、 \(\text{undefined}\) とする。

  例：以下のような列は大文字で表す。
  - \(()\) ... 空列
  - \((0)\) ... `-`
  - \((2)\) ... `- l l`
  - \((1,2)\) ... `- l - l l`
  - \((0,2,0)\) ... `- - l l -`

\(\Sigma^*\) とテープの対応
: \(p \in \Nat^k\) に対して定義された \(\psi(p) \in \Sigma^*\) に対しては、
  これをテープと考えるときには、左は全部空白、ヘッドは左側の \(x\) の位置としておく。
  inline code で書くときにはこういう風になっている。
  
  `... - | x | F(p) x - ...`

> [!Note]
> \(k\) 個の tuple の場合、`x` ではさまれた中に \(k\) 個の空白記号 `-` があることがわかる。

### チューリングマシンの計算する関数
こうしてテープの解釈が定まったので、自然数関数を計算するマシンの定義ができる。
\(n\) 引数の関数とは \(\Nat^n \to \Nat\) のことである。

チューリングマシンにより計算可能な関数
: - \(f\): \(\Nat^k\) から \(\Nat\) への部分関数とする。
  - \(M\): \(\Sigma\) 上のTuring machine とする。
  - \(M\) が \(f\) を計算するとは、任意の \(p \in \text{Dom} f\) に対して \(\phi(p) \rightarrow^{M} T\) かつ \(\psi(T) = f(p)\) がなりたつことをいう

## 再帰関数の計算可能性
再帰関数は計算可能であることを示す。
ここで用いるチューリングマシンは二種類ある。
1. 再帰関数を実際に計算する
2. 補助的な動きをする

ここで、 再帰関数を実際に計算するマシン 1. に該当するものは、
「最初に受け取ったテープの左側にはいかなる計算状況においても変更しないし見に行かない」（＊）ものとする。
これを仮定することで扱いやすくなる。

また、再帰関数 \(f(n_0, \ldots n_k)\)を実際に計算するマシンは次のように入力と出力を受け取る。
- 入力： `... - | x | - l(n_0) - l(n_1) - ... - l(n_k) x - ...`
- 出力： `... - | x | - l(f(n_0, ..., n_k)) x - ...`

### 基本関数を計算するマシン
ゼロ定数関数
: - 入力： `... - | x | x - ...` 
  - 出力： `... - | x | - x - ...` 

後者関数
: - 入力： `... - | x | - l(n) x - ...` 
  - 出力： `... - | x | - l(n + 1) x - ...` 

射影関数
: - 入力： `... - | x | - l(n_0) - l(n_1) - ... - l(n_k) x - ...`
  - 出力： `... - | x | - l(n_i) x - ...`

これらは簡単に作れるし、（＊）の条件を満たすように作れることがわかる。
実際に作ったものが以下になる。

### 補助的なマシン
合成関数に対応するマシンを計算するにあたり、
次のマシンがあるとよい。

\(n\)-times-copy
: - 入力： `... ? | x | F(p) x - ...`
  - 出力： `... ? | x | F(p) x F(p) x ... x F(p) x - ...` ただし、 `F(p)` が \(n\) 個になっている。

rotate
: - 入力： `... ? | x | F(p_1) x F(p_2) x ... x F(p_{n-1}) x F(p_n) x - ...`
  - 出力： `... ? | x | F(p_2) x F(p_3) x ... x F(p_n) x F(p_1) x - ...`

move
: `x` を目印に右と左に行く。

glue
: - 入力： `... ? | x | F(p_1) x F(p_2) x - ...`
  - 出力： `... ? | x | F(p_1) F(p_2) x - ...`

### 合成関数
合成関数 \(C[f_1, \ldots, f_n; g](p) \)
: \(=g(f_1(p), \ldots, f_n(p))\)

- 関数 \(f_1, \ldots, f_n\) に対応するマシン： \(M_1, \ldots, M_n\)
- 関数 \(g\) に対応するマシン： \(M\)

このとき、合成関数 \(g(f_1(p), \ldots, f_n(p))\) の計算については次のような順序で呼ぶ。
\(n\) については再帰関数の定義を与えられた時点で判明しているから、適当に生成できる。
**注意点**

| やること | 結果（テープ） |
| --- | --- |
| 一番最初の入力状況 | `... - \| x \| F(p) x` |
| `A` を \(n\) 個コピーする。 | `... ? \| x \|  F(p) x ... x F(p) x - ...` |
| 1. 一番右側の \(p\) の位置へ行き <br> 2. \(M_1\) を呼び、 <br> 3. 戻ってくる。 | `... ? \| x \| F(p) x F(p) x ... x - l(f_1(p)) x - ...` |
| ローテーションを行う。 | `... ? \| x \| F(p) x F(p) x ... x - l(f_1(p)) x F(p) x - ...` |
| 1. 一番右側の \(p\) の位置へ行き <br> \(M_2\) を呼び、 <br> 3. 戻ってくる。| `... ? \| x \| F(p) x F(p) x ... x - l(f_1(p)) x - l(f_2(p)) x - ...` |
| ローテーションを行う。 | `... ? \| x \| F(p) x F(p) x ... x - l(f_1(p)) x - l(f_2(p)) x F(p) - ...` |
| これを続ける | \(\ldots\) |
| 一番最後の \(M_n\) に対しても同様にする。 | `... ? \| x \| - l(f_1(p)) x - l(f_2(p)) x ... x - l(f_n(p)) x - ...` |
| 右側が `x` で区切られているため、 glue を利用してこれを除去する。 | `... ? \| x \| - l(f_1(p)) - l(f_2(p)) ...  - l(f_n(p)) x - ...` |
| 状況を確認すると、これは \((f_1(p), \ldots, f_n(p))\) の符号化 `F((f_1(p), ..., f_n(p)))` になっている | `... ? \| x \| F((f_1(p), ..., f_n(p))) x - ...` |
| これに対して \(M\) を呼ぶ。 | `... ? \| x \| - l(g(...)) x - ...` |

注意点として、これを"続ける"の部分はマシンが先に与えられていれば単に順に操作を行うだけでよい。
ループ等の操作は要らない。
これは後述する原始再帰関数の構成とは異なる。

### 原始再帰関数
原始再帰関数 \(P[f_z, f_s](n, p)\) 
: - \(P(0, p) = f_z(0)\)
  - \(P(1 + n, p) = f_s(P(n, p), n, p)\)

- \(f_z\) に対応するマシン： \(M_z\)
- \(f_s\) に対応するマシン： \(M_s\)

肝は、 `x l x` の並びは自然数の組としては絶対に現れないこと。

| やること | 結果（テープ） |
| --- | --- |
| 一番最初の入力状況：入力は \((n, n_1, \ldots, n_k)\) として \(p = (n_1, \ldots, n_k)\) とする。 | `... ? - \| x \| - l(n) F(p) x - ...` |
| マーカーとして `x l x` を挿入する。 | `... ? - \| x \| l x - l(n) F(p) x - ...` |
| 右側を \(n\) の値を下げながらコピーし、 <br> \(n = 0\) になったら \(p\) のみをコピーする。 <br> 返ってくる必要はない。| `... ? - x l x - l(n-1) F(p) x - l(n-2) F(p) x ... x - l F(p) \| x \| F(p) x ...` |
| \(M_z\) を呼ぶ。| `... ? - x - l(n-1) F(p) x ... x - l F(p) \| x \| - l(f_z(p)) x ...` |
| （☆）現在の状況 | `... ? x l \| x \| - l(j) x` or <br> `... ? x - l(m) F(p) \| x \| - l(j) x` <br> ただし、 \(j = P[f_z, f_s](m - 1, p)\) |
| **もし** 左側が `... ? x l` なら、 `x l` を除去し間を詰めて終了する。| `? x l \| x \| - l(j) x` から <br> `? \| x \| - l(j) x` |
| （以降はそうでない場合） 1 つ左へ行く | `... ? \| x \| - l(m) F(p) x - l(j) x` |
| 2 つを入れ替えた後くっつける。 | `... ? \| x \| - l(j) - l(m) F(p) x` |
| 状況確認： \((j = P[f_z, f_s](m - 1, p), m, p)\) だから、 \(M_s((j, m, p)) = P[f_z, f_s](m, p)\) である。 | `... ? \| x \| F((j, m)) F(p) x` |
| \(M_s\) を呼ぶ | `... ? \| x \| - l(j') x` <br> ただし、 \(j' = P[f_z, f_s](m, p)\) |
| （☆）の部分に戻る。 |  |

合成関数と同じように、これも対応する原始関数を計算するマシンを構成している。
どんな大きさの引数が与えられるかマシンを得た段階ではわからないことから、
このマシンの構成にはループが含まれている。
ただし、左側にマーキングして右側から左に順々に畳みこんでいくことからこのループは（与えられたマシンが停止する場合には）必ず停止する。

原始再帰だと、
- `x - l(0) F(p) x` が与えられたら、 `x l x F(p) x` にして `f_z` 呼んで 
- `x - l(1) F(p) x` が与えられたら、 `x l x - l(0) F(p) x F(p) x` にして、
  - `f_z` 呼んで `x l x - l(0) F(p) x - l(f_z(p)) x` 後処理して `x l x - l(f_z(p)) - l(0) F(p) x` ... `x l x F(f_z(p), 0, p) x`
  - `f_s` 呼んで終わり。

そのため、与えられた \(n\) から \(1\) だけずらす必要がある。

### \(\mu\) 再帰関数
再帰関数 \(\mu[f](p)\)
: \( = \min \{n \mid f(n, p) = 0\}\)

- \(f\) に対応するマシン： \(M_f\)

| やること | 結果（テープ） |
| --- | --- |
| `... ? \| x \| F(p) x - x` と変形する。| `... ? \| x \| F(p) x - x` |
| （☆）現在の状況 | `... ? \| x \| F(p) x - l(n) x` |
| copy, rotate を使って右のように変形する | `... ? \| x \| F(p) x - l(n) x - l(n) F(p) x` |
| 右に 2 回行く | `... ? x F(p) x - l(n) \| x \| - l(n) F(p) x` |
| \(M_f\) を呼ぶ | `... ? x F(p) x - l(n) \| x \| - l(f(n, p)) x` |
| もし右側が \(0\) ならループを抜けて（〇）に行く | `... ? x F(p) x - l(n) \| x \| - x` |
| （以降は \(0\) でない場合）：右側を消して左側に行く | `... ? x F(p) \| x \| - l(n) x - ...` |
| 右に \(1\) を足したら左側に行く | `... ? x F(p) \| x \| - l(n + 1) x - ...` |
| （☆）に戻る | |
| （〇）現在の状況 | `... ? x F(p) x - l(n) \| x \| - x` |
| 右側を消したら左に 2 回行く | `... ? \| x \| F(p) x - l(n) x - - ...` |
| rotate して `l(n)` を前に持ってきてから残りを消す | `... ? \| x \| - l(n) x - ...` |

これも対応する \(\mu\) 再帰関数を計算している。
万が一与えられたマシンが与えられた入力に対して \(0\) を出力するような \(n\) を持たない場合、
このマシンは止まらない。
