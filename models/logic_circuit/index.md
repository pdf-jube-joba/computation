メモ：思い出した。ピンを本当に自然数で番号づければいいとか考えていた。

<div data-model="logic_circuit">
<script type="text/plain" class="default-code">
graph: one-shot {
    in {I}
    out {O=A.OUT}
    B, BR-F {IN=I}
    N, NOT-T {IN=B.OUT0}
    A, AND-F {IN0=B.OUT1, IN1=N.OUT}
}
</script>
<script type="text/plain" class="default-ainput">
</script>
</div>

それと、 `RInput` と `ROutput` で Signal を扱うのはおかしくて、
他からのコンパイルの結果として何か（任意有限な自然数のような）ちゃんとした入力を扱うことができていない状態になっている。

## 形式的な定義
論理回路の本を読んでも数学的構造として何かといった議論はあまりないか、あったとしてもチューリング完全にはならないような定式化をしていることが多い（有限なゲートの組み合わせだとダメそう）。
一方で、論理回路の本を読めば数学的構造として定義するなら何を定めればいいかは容易に察せる（と思う）。
ただ、定義しようとするとめんどくさいし間違いは多そう。
ここではその定式化を使うことにする。

ただし、普通のやり方で論理回路から作ろうとすると問題があるため、
ここでは問題点を回避するために煩雑なことをたくさんやる必要が出てきた。
主な問題点は、チューリング同値のとこで話していた「計算モデルは各計算に対応するものが有限な方法で記述できる必要がある」ことと、チューリング完全性の両立である。
おそらく論理回路を考える人はチューリング同値にする必要がないので、こんなことを議論しないでいいようになっているに違いない。

あと、普通の論理回路の議論では現実に立ち向かっているので、遅延とか構成部品の特性（電圧とかの応答？）を考える必要があり、どう配置するかも問題になってくる。
（グラフを平面に配置する。）

> [!NOTE]
> 計算の複雑性の理論では、boolean circuit と呼ばれるものがかなり形式的に定義されている。
> nand2tetrisでは、dffをゲートの一つに入れて考えているが、あまり形式的に意味論を与える本ではない。
> 読み取れてないだけかもしれないが。

ゲートのラベルの定義
 : ラベルと呼ばれる、グラフの頂点に貼り付ける用の集合を次のように（複数に分けて）定義する。 
    - 論理ゲートのラベルと呼ばれる集合 \(G\) を \(\{\text{AND}, \text{OR}, \text{NOT}\}\) とする。
    - 分岐を行うためのラベルとして \(B = \{\text{BR}\}\) を用意する。
    - 定数を出力するラベル \(C\) を \(\{\text{C0}, \text{C1}\}\) とする。
    - 入力を捨てるためのラベルとして \(E = \{\text{END}\}\) と定める。 
    - 入力ラベル \(I\) を \(\{\text{IN}(n) \mid n \in \mathbb{N}\}\) とする。
    - 出力ラベル \(O\) を \(\{\text{OUT}(n) \mid n \in \mathbb{N}\}\) とする。
    - ラベルの全体\(\text{Label}\) は \(G \cup B \cup C \cup E \cup I \cup O\) とする。

論理回路はグラフ（の頂点）に上のラベリングをするものになる。
ただし、制限をつける必要があるため、そのための語彙として次のものを導入しておく。
- 復習もかねて、グラフとは集合 \(V\) （頂点の集合と呼ばれる）と \(V \times V\) の部分集合 \(E\) （辺の集合と呼ばれる）の組 \((V,E)\) のことである。
    - 多重辺を入れなくてよいのでこっちを採用した。
    - 以降はなんも調べずに作った記号なので信用してはいけない。
- \(v, v' \in V\) に対して、 \(v \rightarrow v'\) を \((v, v')\) と思うことにする。
    - \(v \rightarrow v' \in E\) とか書く。
- \(\cdot \rightarrow v\) は \(V\) の部分集合 := \(\{v' \in V \mid v' \rightarrow v \in E\}\)
- \(v \rightarrow \cdot\) は \(V\) の部分集合 := \(\{v' \in V \mid v \rightarrow v' \in E\}\)

論理回路
: 論理回路とは有向グラフ \((V,E)\) と \(l\): \(V \to \text{Label}\) の組であって、 \(v \in V\) ごとに次の条件を満たすものとする。
    - \(\{ n \in \mathbb{N} \mid l v = \txtop{In} n\}\) はある自然数 \(k\) によりちょうど \(\{0 .. k\}\) とあらわされるか、自然数全体に一致する。
    - \(\{ n \in \mathbb{N} \mid l v = \txtop{Out} n\}\) はある自然数 \(k\) によりちょうど \(\{0 .. k\}\) とあらわされるか、自然数全体に一致する。
    - 次の表のとおりになっていること。
        | \(l(v)\) | \(\# (\cdot \rightarrow v)\) | \(\# (v \rightarrow \cdot)\) |
        |---------|---------|--------|
        | AND     | \(2\) | \(1\) |
        | OR      | \(2\) | \(1\) |
        | NOT     | \(1\) | \(1\) |
        | C0      | \(0\) | \(1\) |
        | C1      | \(0\) | \(1\) |
        | BR      | \(1\) | \(2\) |
        | IN      | \(0\) | \(1\) |
        | OUT     | \(1\) | \(0\) |

論理回路 \((V,E,l)\) に対して \(\text{In}(V,E,f) = \text{Im} f \cap I\) 、 \(\text{Out}(V,E,f) = \text{Im} f \cap O\) とする。

> [!NOTE]
> ふつう論理回路といえば、頂点や辺の数が有限な論理回路のことでよいはずだ。
> しかしそのように定めると明らかにチューリング同値にはならない（メモリに対応する部分が有限になるから）。
> 一方で、単に可算無限な論理回路を考えると、
> こんどはチューリングマシンでエミュレートができないぐらいの計算能力をもってしまう。
> ちょうどいいモデルをずっと探していたが見つからなかったので、
> 頑張ってチューリング同値になるように定義しつつ、
> 同値になることは証明しない方針で行こうと思う（よくないけど）。
> 候補を 2 個考えた。
> どっちがいいかはわからないのでとりあえず 2 個載せておく。

上の Note でも書いたようにこのままだと論理回路のちょうどチューリング同値な subset を見つけることができていないので、**後で** これを修正する。
その前に、論理回路自体をどのように動かすかを記述しておく。

論理回路の状態
: 論理回路 \((V,E,l)\) を固定する。
  論理回路 \((V,E,l)\) の状態とは、 \(V \to \{0,1\}\) のことである。

論理回路の状態は得られたので、あとはどのように動くか（どのように状態が変化していくか）を述べればよい。

論理回路の遷移
: 論理回路 \((V,E,l)\) の状態 \(s\) が与えられたとき、 \(s\) の次の状態 \(s^\prime\) を次のように定める。
- \(l v = \text{AND}\) のとき
    - \(0 \in \{s v^\prime \mid v^\prime \rightarrow v\}\) なら \(s^\prime v = 0\)
    - そうでないなら \(s^\prime v = 1\)
- \(l v = \text{OR}\) のとき
    - \(1 \in \{s v^\prime \mid v^\prime \rightarrow v\}\) なら \(s^\prime v = 1\)
    - そうでないなら \(s^\prime v = 0\)
- \(l v = \text{NOT}\) のとき
    - \(\{s v^\prime \mid v^\prime \rightarrow v\}\) は一元集合のはずなので \(\{x\}\) と表せる。
    これを用いて \(s^\prime v = 1 - x\) （これは \(0, 1 \mapsto 1, 0\) をしたいだけ。）
- \(l v = \text{BR}\) のとき
    - \(\{s v^\prime \mid v^\prime \rightarrow v\}\) は一元集合のはずなので \(\{x\}\) と表せる。
    これを用いて \(s^\prime v = x\)
- \(l v = \text{OUT} \) のとき
    - \(\{s v^\prime \mid v^\prime \rightarrow v\}\) は一元集合のはずなので \(\{x\}\) と表せる。
    これを用いて \(s^\prime v = x\)
- \(l v = \text{In} \) のとき \(s ^\prime v = s v\)

論理回路の安定
: 論理回路の状態 \(s\) が安定状態であるとは次の状態が同じ \(s\) になることをいう。

> [!Note]
> この安定という語は学術用語として使うかわからないけど、授業では（形式的には定義されなかったが）使った。
> フリップフロップなどで定常状態云々みたいな感じ。

このままでもいいのだが、開始状態がいい感じに定まっているとよい。
重要な点として、入力がすべて \(0\) ならなにも動かないとよい。

論理回路の開始状態
: 論理回路 \((V,E,l)\) の開始状態とは、状態 \(s\) であって安定していて \(s \{\txtop{In}(V,E,l)\} = \{0\}\) となっているもののこと。

以降では論理回路といったら開始状態も加えて \(4\) つの組 \((V,E,l,s)\) のように書くことにする。
論理回路 \(G_i = (V_i, E_i, l_i, s_i)\) があるとき、この入出力をつなぎ合わせることで \(1\) つの論理回路 \(G_1 \# G_2\) が構成できる。

論理回路の入出力辺の結合
: 論理回路 \((V, E, l)\) に対して、
  \(v, v' \in V\) であって \(l(v) \in \text{IN}, l(v') \in \text{OUT}\) となっているものに対して、
  次のように定義される論理回路を \((v, v')\) の結合と呼ぶことにする。
    \[(V - \{v, v'\}, E \cup \{v'_2 \rightarrow v_2\} - \{v \rightarrow v_2, v'_2 \rightarrow v'\}, l\mid_{\text{restriction}})\]
論理回路の結合
: 2つの論理回路 \((V_i, E_i, l_i)\) があったとして、
    \(V_1 \cap V_2 = \emptyset\) を満たしているとする。
    これを並べる。

\((V, E)\) の部分は必要に応じて集合の全単射を通じて被らないように変更してしまっていい。

### 1 つめの定義（計算可能な関数を使ってしまう場合）
有限な回路の（計算可能な）極限で表したり、"計算可能な関数"という概念が定まっている中で定義するならそこまで難しくはない。

計算可能な回路の定義１
: 有限な回路の列で定義する。
  各 \(n\) に対して論理回路 \((\{0..n\}, E_n, l_n, s_n)\) があるとする。次の条件が保たれるなら計算可能といい、これの極限を計算可能な回路という。
    - \(E_n \subset E_{n+1}\) が成り立って、\((i, j) \in \bigcup_{k} E_k\) なら \((i, j) \in E_{\max(i,j)}\)
    - ラベリングや状態が \(\{0..n\} \to \{0..{n+1}\}\) なる埋め込みと compatible である。
: 決定可能な関数で定義する。
  論理回路 \((\mathbb{N}, E, l, i)\) と関数 \(f\): \(\mathbb{N} \to \mathbb{N} \times \mathbb{N}\) の組であって、次の条件が保たれるなら計算可能という。
    - \(E = \text{Im} f\)
    - \(f\) は次のようにして定義される全順序を保つ: \((i,j) \leq (k, l) \leftrightarrow \text{max} \{i,j\} \leq \text{max} \{k,l\}\)

> [!Note]
> こうしておけば、チューリングマシンでエミュレートできるはず。
> 開始状態が安定していて、辺が計算可能関数で記述できて、となっているので、
> テープに最初の情報を載せておいて、必要になったら、論理回路を拡張していけばよいので計算できる。
> これって要は、"プログラム"で書ける論理回路のことになる。
> あとから気が付いた：結局、 \(\mathbb{N} \to \text{Label}\) が"計算"できないといけない。

### 2 つめの定義（ iteration を繰り返して得られる論理回路）

繰り返し論理回路
: 次の帰納的な構成により得られる回路を繰り返し回路という
    - 有限論理回路は繰り返し論理回路である。
    - 繰り返し論理回路に結合を行ったものも繰り返し論理回路である。
    - 繰り返し論理回路の直和は繰り返し論理回路である。
        - これは、  \((V, E, l), (V', E', l')\) から \((V \sqcup v', E \sqcup E', \text{mix}(l, l'))\) みたいな操作

> [!WARNING]
> - 注意点として、入出力のラベルの番号付けはちゃんとやらないといけない。
> - 繰り返し回路 \((V, E, l)\) に対して、 \((v^{\text{in}}_i, v^{\text{in}}_j)\) を使って、 \((V \times \Nat, \{(v, i) \rightarrow (v', i) \mid v \rightarrow v' \in E\}, l)\) に対して結合を行う。
