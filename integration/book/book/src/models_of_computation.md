# 計算モデル
## この章でやること
自然数関数のうち再帰関数と呼ばれるクラスの関数を定義する。
そののちに代表的な計算モデルである Turing machine ・ラムダ計算・ While プログラム・レジスターマシンなどに触れ、
再帰関数が計算可能であることについて触れる。

## はじめに
自然数関数全体を考えたとき、ある手続きを得て作られる関数のクラスとして再帰関数というものがある。
再帰関数は、定数関数・1を足す関数・射影関数から始まり、関数合成・原始帰納法・ \(\mu\) 帰納法と呼ばれる構成を繰り返すことで得られる関数のことを言う。
再帰関数は通常想像されるような単純な関数（足し算や掛け算に始まり多項式関数など）以外にも様々な関数が含まれる、非常に大きなクラスである。

ところで、可能な関数の定義の仕方とはどれぐらいあるのだろうか。
例えば、「リーマン予想が真のとき \(0\) を返し、偽のとき \(1\) を返す関数」のような関数の定義の仕方は正当に思える。
ではこの関数の値は何なのか。
このようなことを考えると、関数を定義したからと言って必ずしもその値が"計算"できるとは限らないことがわかる。
その点で、再帰関数は"計算ができる"関数の全体をうまく表していると思える。

しかし、よりよい"計算"のモデルを定義することで、この"計算ができる"関数の全体を大きくすることはできないだろうか。
実はできない。
数学的構造としての"計算モデル"は一般に定義されていないが、"計算を行っている"とみなせる数学的なモデルを様々な人が考えてきた。
しかし、そのいずれもが、計算できるクラスは再帰関数に一致するかそれよりも小さくなってしまうことが知られている。
このことから、 Church-Turing のテーゼと呼ばれる「計算可能な関数をこの再帰関数で定義しようという提唱」が唱えられた。

この章では以下の計算モデルを紹介し、それぞれにおいて再帰関数が計算できることについて触れる。
- Turing machine
- ラムダ計算
- while プログラム
- レジスターマシン

こうしてえられた様々な計算モデルには（本質的には同じだと思うが）もう一つ面白い共通の性質がある。
それは互いが互いをエミュレートできるというところである。
ある計算モデルが Turing machine をエミュレートできるとき、その計算モデルはチューリング完全であるという。
上に述べたことから、チューリング完全な計算モデルはその計算能力においては Turing machine と同等であると予想され、
ほぼ全ての"計算"が行える、すなわち計算能力においては最上位にあることがわかる。
（Turing machine より強い計算モデルを作るには工夫（オラクルの導入など）がいるが、より強い計算モデル自体は存在する。
ただし、そのいずれの方法もおそらく従来の「計算とはなにか」の直感に照らし合わせると、だいたい計算っぽいものよりも強い何かを持っていることが多いので、
その点でいうと順当に予想される計算を行うような範囲では、 Turing machine を超える計算モデルは作れなさそう。）

<!-- ### 再帰関数
自然数関数のうち、非常に自明なものから始まり、すでに得られている関数をもとに合成や帰納法に基づく構成などを繰り返して得られる関数のことを言う。
非常に多くの関数がここに含まれることがわかる。
計算モデルとはあまり言われないと思う。
（もしかしたら「計算モデル」の厳密な定義によっては計算モデルではないかもしれない。）

### チューリングマシン
チューリングマシンとは、左右無限のテープに書かれた記号と自身の状態を、あらかじめ定義された遷移表にのっとって操作する、仮想の機械である。

### チューリングマシンの計算可能な関数
自然数とテープの間の変換を考えることでチューリングマシン（のうち一部）を自然数関数とみなすと、再帰関数はチューリングマシンによってあらわせることがわかった。

### Universal なチューリングマシン
全く詳しく触れてないが、チューリングマシンの動作を模倣する Universal なチューリングマシンがあることについて触れた。

### ラムダ計算
ラムダ計算は、変数とラムダ抽象と関数の適用により得られるラムダ式を、代入による式を簡約を計算ととらえることで得られる計算モデルである。

### while プログラム
while プログラムは変数への操作と条件を満たしているかどうかの判定からなる文で構成される言語である。
変数と値の対応を環境と呼び while プログラムがこれに作用しているとみなすことで計算モデルとすることができる。

###  -->
