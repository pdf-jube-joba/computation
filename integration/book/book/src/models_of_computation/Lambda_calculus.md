# ラムダ計算
## ざっくりとした説明ととりあえず動く見本
ラムダ計算とは、ラムダ項と呼ばれる式と、その間の"変換"と呼ばれる関係式により、式をどんどん変形していく計算モデルである。

- ラムダ項は変数・関数の宣言・関数の関数適用、みたいなもののみを使って作られる
- ラムダ項は現れる変数を（その束縛に注意しつつ）適当に変更してよい
- ラムダ項はその中に関数の関数適用がある場合、関数を呼び出した結果で置き換えてよい

この変換は、どの部分を先に変更するかによって結果が変わってくるが、ラムダ項の変換はどの順でやってもだいたい合流する。
この点で、ラムダ計算は、"次にどう変化するか"が指定されていない計算モデルである。
（計算モデルとは何かが具体的に数学的構造として定まっているわけではないので、まあ「○○は計算モデルである」というのはあまり意味のない言葉ではある。）

一方で、ラムダ計算はたしかに計算現象をとらえているようにも思えるし、チューリングマシンと同じぐらい複雑で、
特に、（適当な符号化というか同一視というかそんな感じのやつによって）再帰関数を計算しているとみなすことができる。

注意点として、ラムダ項の定義を見ると、自然数や足し算などの"余計な"記号が一切入っていないのでわかりにくいかもしれない。

## 定義
### 変数について
まず変数の集合 \(\Lambda\) を適当に固定しておく。
これは無限集合ならほとんどなんでもよいが、プログラミングや形式的な扱いの上では

- 2 つの変数が等しいかどうかが簡単に決定できる（ \(\Lambda \times \Lambda \to \text{bool}\) みたいな写像が構成できる）
-  有限な部分集合に対してはその部分集合に含まれないような変数をとることができる（ \(\mathop{\text{finite subset of}} \Lambda \to \Lambda\)）

とよい。

### ラムダ項の定義
> **definition**
> ラムダ項は以下の帰納的な定義で得られるもの（のみ）をいう。
> - 変数はラムダ項である。
> - 変数 \(x\) と ラムダ項 \(M\) に対して \(\lambda x.M\) はラムダ項である。このラムダ項をラムダ抽象という。
>     - ラムダ抽象は変数 \(x\) で引数を指定し、 \(M\) で関数の中身を述べている。
> - \(2\) つのラムダ項 \(M_1, M_2\) に対して \((M_1 M_2)\) はラムダ項である。このラムダ項を関数適用という。
    - 関数適用は関数を引数で呼び出すものに対応する。 関数 \(f(x)\) に \(1\) を代入するのを \(f(1)\) のように書いたりするが、ラムダ計算の中では"関数" \(M_1\) を引数 \(M_2\) で呼び出すのを \((M_1 M_2)\) と書く（ \(M_1(M_2)\) ではない）。

ラムダ抽象は、関数に名前を付けることなく関数を述べることができるので、プログラミング言語の中でも似たようなものが使われることがある。
例えば、 \(x\) を受け取って \(x + 1\) を返す関数を \(\lambda x.x+1\) のように書いたりする人もいるが、これもまたラムダ抽象と呼ばれたりもする。 
また、関数適用も同じようにラムダ計算以外の文脈で記法が使われることがある。

| 流儀 | 関数 | 関数の呼び出し |
| --- | --- | --- |
| 数学でよく書く | \(f(x)\) | \(f(1)\) |
| ラムダ項っぽい | \(f\) | \((f 1)\) や \(f 1\) |

ラムダ項を latex で書くのはめんどくさいので、ここでは `x` や `\x.M` や `M N` のように書くこともある。
\\ が \(\lambda\) に対応している。
また、 \(M_1 \cdots M_n\) は \(( \cdots ((M_1 M_2) M_3) \cdots M_n)\) の略記とする。
さらに、 \(\lambda x_1 \cdots x_n. M\) は \(\lambda x_1. \lambda x_2. \cdots \lambda x_n.M\) の略記とする。
また、特に断りがなければ、小文字は変数、大文字はラムダ項を表す。

> **definition**
> ラムダ項の部分項を次のように定義する。
> - \(M\) 自身は \(M\) の部分項である。
> - \(M\) の部分項は \(\lambda x.M\) の部分項である。
> - \(M\) の部分項は \((M N)\) の部分項である。
> - \(N\) の部分項は \((M N)\) の部分項である。

### ラムダ項の中に現れる変数の気持ち
ラムダ項を実際に計算する前に変数について注意しておかないといけない。
ここではわかりやすさのためにラムダ項を適当に拡張し \(M + N\) とか数字もラムダ項に含まれている感じで扱う。
あくまでも具体例のため。

`\x.x` はラムダ抽象によって関数を定義しているが、中にあらわれる `x` はラムダ抽象によってちょうど **束縛** されて、代入時にちょうど置き換えられる。
例えば、 `\x.x` に `1` を代入すると `1` になり、 `\x.x+3` に `1` を代入すると `1+3` になる。
一方で `\x.y` は `x` が束縛されていて `y` は束縛されていない。
だから、 `\x.y` に `1` を代入すると `y` になり `\x.y+3` に `1` を代入すると `y+3` になる。
この具体例で出てきた `y` はラムダ抽象によって縛られていない **自由** な変数である。

関数を述べるときにどの変数を用いて定義するかは関数の本質ではなく、束縛する変数を一斉に付け替えることができる。
ちょうど \(\sum_i a_i = \sum_j a_j\) のように変数を付け替えるように、 `\x.x` と `\y.y` を同一視したい。
一方で、付け替えの中で余計な変数が束縛されないようにしなければいけない。
\(\sum_i \sum_j a_{i,j} = \sum_i \sum_i a_{i,i}\) のような変形をしてはいけないのと同様の理屈である。
`\x.M` に `N` を代入しようとするとき、 `N` に含まれる自由な変数が誤って束縛されることがないように `\x.M` 自身の束縛を取り替えて `\y.M'` のようにしなければいけない。
また、 \((y \y.y)\) のように、 \(y\) が自由な出現をしていながら別のところで束縛された状態で出現することもある。
このような項は \(2\) つの \(y\) は異なるものとして認識される必要がある。

### ラムダ項の中にあらわれる変数と、変数の付け替え

> **definition**
> ラムダ項 \(M\) の自由変数全体 \(\text{FV}(M)\)を次のように定義する
> - 変数 \(x\) に対して \(\text{FV}(x) = \{x\}\)
> - 変数 \(x\) とラムダ項 \(M\) に対して \(\text{FV}(\lambda x.M) = \text{FV}(M) - \{x\}\)
> - ラムダ項 \(M, N\) に対して \(\text{FV}(M N) = \text{FV}(M) \cup \text{FV}(N)\)
> 
> ラムダ項の束縛変数全体 \(\text{BV}(M)\) を次のように定義する。
> - 変数 \(x\) に対して \(\text{BV}(x) = \emptyset\)
> - 変数 \(x\) とラムダ項 \(M\) に対して \(\text{BV}(\lambda x.M) = \{x\} \cup \text{BV}(M)\)
> - ラムダ項 \(M, N\) に対して \(\text{BV}(M N) = \text{BV}(M) \cup \text{BV}(N)\)

変数の置き換えについて議論するため、 **ラムダ計算で必要とされる代入とは異なる**代入を定義する。
非常に単純な代入の仕方を次で定義する。
ラムダ項 \(M\) に対して、自由に出現する変数 \(x\) の \(N\) への置き換え \(\text{subst}(M,x,N)\) を次で定義する。
- 変数 \(x\) に対して、 \(\text{subst}(x,x,N) = N\)
- \(x\) とは異なる変数 \(y\) に対して \(\text{subst}(y,x,N) = y\)
- 変数 \(x\) とラムダ項 \(M\) に対して \(\text{subst}(\lambda x.M, x,N) = \lambda x.M\)
- \(x\) とは異なる変数 \(y\) とラムダ項 \(M\) に対して \(\text{subst}(\lambda y.M, x,N) = \lambda y.\text{subst}(M,x,N)\)
- \(2\) つのラムダ項 \(M_1, M_2\) に対して \(\text{subst}((M_1 M_2), x, N) = (\text{subst}(M_1, x, N) \text{subst}(M_2, x, N))\)

この代入を用いて、アルファ同値と呼ばれる「束縛変数の違いを無視して同一視する」同値関係 \(\sim_{\alpha}\) を次のように定義する。

> **definition**
> ラムダ項の間の関係 \(\sim_{\alpha}\) を次のように定義する。 
> - 変数 \(y\) とラムダ項 \(M\) に対して \(y \notin \text{FV}(M)\) ならば、 \(\lambda x. M \sim_{\alpha} \lambda y.\text{subst}(M, x, y)\) である。
> - \(M \sim_{\alpha} M\) 
> - \(M_1 \sim_{\alpha} M_2\) なら \(\lambda x. M_1 \sim_{\alpha} \lambda x. M_2\)
> - \(M_1 \sim_{\alpha} M_2\) かつ \(N_1 \sim_{\alpha} N_2\) なら \((M_1 N_1) \sim_{\alpha} (M_2 N_2)\)

だいたい次のようなことが成り立つはず。
- アルファ同値は同値関係
- アルファ同値は自由変数を保つ
- どのラムダ項も束縛変数と自由変数が被らないような別のラムダ項にアルファ同値である

また、変数を気にせずに式全体がどのような木構造をしているかを考えると、アルファ同値はこの木構造も保っている。
すなわち、ラムダ抽象や適用、変数がどこででてくるかは完全に一致しているはずである。

ラムダ項をアルファ同値なラムダ項に変更することをアルファ変換という。
ただし、ラムダ項に対してアルファ変換な別のラムダ項が一意に定まっているわけではないので、
アルファ変換は関数ではなく関係である。

### 代入とベータ変換
以上をもとに**通常の**代入とベータ変換と呼ばれる写像が定義できる。

> **definition**
> ラムダ項 \(M\) に対して、変数 \(x\) とラムダ項 \(N\) による代入 \(M[x:=N]\) を次のように定義する。
> - 変数 \(x\) に対しては \(x[x:=N] = N\)
> - \(x\) と異なる変数 \(y\) に対しては \(y[x:=N] = y\)
> - ラムダ抽象 \(\lambda x. M\) に対しては \((\lambda x.M)[x:=N] = \x.M\)
> - \(x\) と異なる変数 \(y\) に対しては
>   - \(y \notin \ltext{FV}(N)\) ならば \((\lambda y.M)[x:=N] = \lambda y.(M[x:=N])\)
>   - そうでない場合には、 \(\lambda y.M\) とアルファ同値で条件を満たす \(M^\prime\) を用いて \(M^\prime[x:=N]\) とする

この代入が正常に定義されているか確認する必要がある。
- アルファ同値で条件を見た満たす \(M^\prime\) のとりかたに"よらず"に定まるか、
    - これは up to アルファ同値でしか定まっていない
- 関数が正常に値を計算できるか
    - ふつうは関数 \(f\) を定義する際に \(f\) を用いた場合、 \(f\) がしっかり定義されているか確かめる必要がある。
        - 例えば、 「\(f\) を \(f(x)^2 = 1\), \(f(1)=1\) を満たす連続写像により定義する」といったとき \(f\) が一意に存在するかを議論する必要がある
        - 他にも 「 \(f\) を \(f(0) = 0\), \(f(x+1) = f(x) + 1\) で定義する」など定義部分で \(f\) を用いている場合、計算が実際にすべての値で進むことを示す必要がある。
    - 今回の場合はラムダ項の構造に対する帰納法に見えて、一番最後の項が必ず停止するかどうかがわからない。
        - つまり、 \(M_1[x:=N]\) を計算するために \(M_2[x:=N]\) を計算するために...と、アルファ同値で置き換えると問題が大きくなり続けて値の計算ができないかもしれない。
    - これを回避するためには、アルファ同値がラムダ項の木構造を保っていることを考える必要があるが、それを考えるとほぼ自明

ラムダ項の部分項であって \((\lamdba x. M N)\) の形をした部分項を \(\beta\) 簡約基と言う。
\(\beta\) 簡約基 \((\lambda x. M N)\) を \(M[x:=N]\) で置き換えることを \(\beta\) 簡約という。
\(\beta\) 簡約基は \(1\) つのラムダ項の中に複数ありえるため、 \(\beta\) 簡約は一意に定まらない。
\(\beta\) 簡約を定式化すると次のようになる。

> **definition**
> ラムダ項の間の関係 \(\to_{\beta}\) を次で定める。
> - \((\lambda x. M N) \to_{\beta} M[x:=N]\)
> - \(M \to_{\beta} N\) なら \(\lambda x. M \to_{\beta} \lambda x. N\)
> - \(M_1 \to_{\beta} M_2\) なら \((M_1 N) \to_{\beta} (M_2 N)\)
> - \(N_1 \to_{\beta} N_2\) なら \((M N_1) \to_{\beta} (M N_2)\)

> **definition**
> ラムダ項の間の関係 \(\twoheadrightarrow_{\beta}\) を \(\to_{\beta}\) の推移閉包として定める。
> ラムダ項が \(\beta\) 簡約基を持たないとき、正規形と呼ぶ。
> ラムダ項が自由変数を持たないとき閉項と呼ぶ。

正規形を持たないラムダ項が存在するが、正規形を持つかどうかは決定することができない。

> **theorem**
> 合流性：ラムダ項 \(M\) に対して \(M \to_{\beta} M_1\) かつ \(M \to_{\beta} M_2\) ならば、ある \(N\) が存在して \(M_1 \twoheadrightarrow_{\beta} N\) かつ \(M_2 \twoheadrightarrow_{\beta} N\) が成り立つ。
> 正規形の一意性：ラムダ項 \(M\) に対して \(M \twoheadrightarrow_{\beta} N\) であって正規形であるような \(N\) はアルファ同値を除いて一意である。

ラムダ項 \(M\) からどのように \(\beta\) 簡約基を選んで簡約するかを決定する方法を、評価戦略と呼ぶ。
どんな評価戦略をとっても、正規形が得られればそれは他の評価戦略で得られた結果と一致している。
この意味で、簡約結果は一意である。
ラムダ項を簡約してゆき正規形を得ようとすることが、ここでは計算と呼べる。

評価戦略をいくつか紹介する

> **definition**
> 最左最外戦略： \(\beta\) 簡約基のうち、最も外にあり最も左にあるものを評価する戦略をこう呼ぶ。
> 値呼び、名前呼び： \(\beta\) 簡約基 \(((\lamdba x. M) N)\) に対して引数 \(N\) を評価しきってから簡約を行うことを値呼びという。名前呼びは引数 \(N\) を評価する前にこの簡約基を簡約する。
> parallel reduction：これは評価戦略というか \(\beta\) 簡約関係をより扱いやすくするために作られた新たな関係のことになるが、だいたい引数とかを同時に一回ずつ簡約するもののことを言う。

最左最外簡約は非常に強い性質を持つ。

> **theorem**
> ラムダ項が正規形を持つなら最左最外簡約を繰り返すことで到達できる。
