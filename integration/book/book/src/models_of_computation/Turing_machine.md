# チューリングマシン
## 注意
チューリングマシンの定義は複数あり、本によって異なる。
標準的なものはないようなので、都合のいい感じで定義している。
- [ ] 参考にした文献を列挙する。

## ざっとした説明ととりあえず動く見本

チューリングマシンの構成要素はだいたい以下の通り
- 記号が書かれた左右無限のテープ
- 状態を持つ制御部
- プログラムとか遷移表とか言われるような、「状態と記号」から次の「状態と記号及びテープの動かし方」への対応一覧
このプログラムに従ってテープと制御部を動かしていくことで、テープを書き換えながら動作する。
最終的に終了状態と呼ばれる状態に行きついたら動作は終了であり、どんなテープを入力すると停止するのか、その時のテープの状態はどうか、
といった部分を計算とみなすことができる。

例えば、次の例はテープに書かれた二つの二進数の足し算を行う。

<component id="example_bin_adder">

## 定義
空白記号（ blank symbol ）と呼ばれるものを固定し、 \(\mathbb{B}\) と書く。
この元は後述する集合に含まれたりするが、チューリングマシンの定義を通して固定をしておく。

> **Note**
> 普通はこの空白記号もチューリングマシンの定義に含めるが、にもかかわらず、
> 異なるマシンで空白記号が共有されているかのような議論が多かったため、ここでは固定した。

> **definition** 次の組をチューリングマシンと言う。
> - \(\Sigma\) : \(\mathbb{B}\) を含む有限集合...この集合の元を記号という
> - \(Q\): 有限集合...この集合の元を状態という
> - \(q_{\text{init}}\): \(Q\) の元...これを開始状態という
> - \(Q_{\text{fin}}\): \(Q\) の部分集合...この集合の元を終了状態という
> - \(\delta\): \(Q - Q_{\text{fin}} \times \Sigma\) から \(Q \times \Sigma \times \{L,R,C\}\) への部分関数

ここで、 \(\delta\) は部分関数であるから、（集合を用いた定義を考えると） \(Q - Q_{\text{fin}} \times \Sigma \times Q \times \Sigma \times \{L,R,C\}\) の部分集合とみなせる。
この関数の元 \((q, \sigma, q^\prime, \sigma^\prime, D)\) をエントリと呼ぶことにする。

> **Note**
> チューリングマシンの他の定義には次のものがある。
> - \(\Sigma\) の部分集合としてさらに \(\Gamma\) なる"入力記号の集合"を指定する
> - \(\delta\) の定義を全域関数とする。これについては後にフォローを行う。
> - \(\delta\) の値域を \(Q \times \Sigma \times \{L,R\}\) とする。
> - \(\delta\) の値域を \(Q \times \Sigma \cup Q \times \{L,R,C\}\) とする。
> - 終了状態の集合 \(Q_{\text{fin}}\)ではなく終了状態 \(q_{\text{fin}} \in Q\) を指定する。

今、集合 \(\Sigma\) に対して（ \(\Sigma\) 上の）テープと呼ばれるものを考える。
このテープとは、各セルに \(\Sigma\) の元が格納されたものが左右無限に並んだもののことを言う。
ただし、テープの中の有限個のセルを除いて、セルは基本的に \(\mathbb{B}\) が入っているものとする。
さらに、このテープには制御部と呼ばれるものがついていて、セルのうちの一つを指し示している。

このテープに対しては次のような操作を行うことができる。
- テープ \(T\) に対して、制御部を一つ右（ resp. 左）に動かしたテープを表す... \(\text{Right} T\) （ resp. \(\text{Left} T\) ）
- テープ \(T\) に対して、制御部の指し示すセルの中身の記号を取り出す... \(\text{Head} T\)
- テープ \(T\) と \(s \in \Sigma\) に対して、制御部の指し示すセルの中身を \(s\) で書き換える... \(\text{write} (T, s)\)

> **Note**
> テープの数学的な定義を形式的に書いているものはほとんどなかった（列の組のように書いているものはあるかもしれない）。
> 一応次の二つの定義が考えられる。
> - 整数の集合 \(\mathbb{Z}\) から \(\Sigma\) への写像であって \(\Sigma - \{\mathbb{B}\}\) の逆像が有限集合になっているものと \(q \in Q\) の組のこと。
>  制御部は \(0 \in \mathbb{Z}\) を指し、状態 \(q\) を保持している。
> - 自然数 \(i\) と、 \(\{1 \ldots i\}\) から \(\Sigma\) への写像であって先ほどと同様の条件を満たすものと、 \(l \in \{1 \ldots i\}\) の組のこと。制御部は \(l\) を指し、状態 \(q\) を保持している。
> なんにせよ、ここで重要なのは \(\text{Right} T\) 、 \(\text{Left} T\) や \(\text{Head} T\) といった操作を行えることである。
> また、テープの定義には \(\Sigma\) が表れるのだが、テープと書いている本が多い。
> ここでは、 \(\Sigma\) 上の、と書くことでテープの定義に言及できるようにした。
> ただしい用語かはわからない。

さらに、有限制御部と呼ばれる、 \(Q\) 上の元を一つ保持するものがある。
（一般には、テープと有限制御部の組をテープと呼ぶことが多い。）

チューリングマシンの計算は遷移関数を用いてテープと状態を変化させていくことで得られる。
> **definition**
> - テープと有限制御部の組を計算状況と呼ぶ。
> - チューリングマシン \(M = (\Sigma, Q, q_{\text{init}}, Q_{\text{fin}}, \delta)\) を固定する。
> 計算状況 \((T, q)\) に対して、\((q, \text{head} T, q^\prime, \sigma, D) \in \delta\) となるエントリがある場合、計算動作と呼び \((T,q) \rightarrow_{M} (D \text{write}(T, \sigma), q^\prime)\) のように書く。
> - そのようなエントリがない場合、停止していると言い、 \(q \in Q_{\text{fin}}\) のとき正常停止と呼ぶ。
> - 計算動作の列 \((T_0, q_0) \rightarrow_{M} (T_1, q_1) \rightarrow_{M} \cdots \rightarrow_{M} (T_n, q_n)\) を計算列と呼ぶ。
> - テープ \(T\) に対して \(P_0 = (T, q_{\text{fin}})\) から始まる計算列 \(P_0 \rightarrow_{M} \cdots \rightarrow_{M} P_n\) であって \(P_n\) が停止しているものを計算過程と呼ぶ。

今、考えたい"計算"があったとして、次のように形式化を定めることでチューリングマシンによる計算ととらえることができる。
- 考えたい計算を形式化する：例えば集合 \(A\) から \(B\) への部分関数 \(f\) とする。
- 二つの集合 \(A\) と \(B\) に対して、適切な符号の集合 \(\Sigma\) と符号化を選ぶ：\(A\) や \(B\) の \(\Sigma\) 上のテープ全体への埋め込み（\(\bar{a}\) や \(\bar{b}\) と書く）を固定する。
- よい条件を満たすチューリングマシン \(M\) を構成する：条件とは、
    - \(a \in A\) に対して、\(f(a)\) が存在すれば、 \(\bar{a}\) の正常停止する計算過程が存在して最後の計算状況が \((\bar{f(b)}, _)\) になっている。
    - \(a \in A\) に対して \(\bar{a}\) の正常停止する計算過程が存在して最後の計算状況が \((T, _)\) になっていれば、 \(f(a)\) が存在して \(T = \bar{f(a)}\) が成り立つ。

> **Note**
> 符号化を選ぶ必要があることに注意する。
> 記号の集合 \(\Sigma\) は有限集合であると決まっているので、例えば自然数上の関数をエミュレートするには \(\Sigma\) として単に自然数全体をとることはできない。
> また、符号化のとり方自体も複数ありうることがある。例えば、自然数の \(\Sigma = \{\mathbb{B}, 0,1\}\) 上のテープへの符号化として、二進数表示を行う以外に \(0\) を使わずに \(1\) を自然数の大きさぶんだけなられる方法も考えられる。

> **疑問**
> 計算可能な自然数の全体って明らかに符号化のとり方による。
> 符号化のとり方自体を"計算可能"なものに限りたいわけだが、その議論は初めにとった符号化のとり方によってしまう。
> 腑に落ちない。

## 具体例
二進数で書かれた自然数に1を足すマシンを作ってみる。
考え方としては、下の桁から線形に見て行けばよい。
\(q_{\text{init}}\) から左に行き、 \(0\) が出てきたら \(1\) に書き換えて終わる。
\(1\) が出てきたら \(0\) に書き換えて、さらに繰り上がりモードを継続する。
