# チューリングマシン
## 注意
チューリングマシンの定義は複数あり、本によって異なる。
標準的なものはないようなので、都合のいい感じで定義している。
- [ ] 参考にした文献を列挙する。

## ざっとした説明ととりあえず動く見本

チューリングマシンの構成要素はだいたい以下の通り

- 記号が書かれた左右無限のテープ
- 状態を持つ制御部
- プログラムとか遷移表とか言われるような、「状態と記号」から次の「状態と記号及びテープの動かし方」への対応一覧

このプログラムに従ってテープと制御部を動かしていくことで、テープを書き換えながら動作する。
最終的に終了状態と呼ばれる状態に行きついたら動作は終了であり、どんなテープを入力すると停止するのか、その時のテープの状態はどうか、
といった部分を計算とみなすことができる。

例えば、次の例はテープに書かれた二つの二進数の足し算を行う。

<component id="turing_machine_example">

## 定義
### チューリングマシンの定義
空白記号（ blank symbol ）と呼ばれるものを固定し、 \(\mathbb{B}\) と書く。
この元は後述する「記号の集合」に必ず含まれることを仮定し、チューリングマシンの定義を通して固定をしておく。

**Note**
この空白記号もチューリングマシンの定義に含める議論も多いが、にもかかわらず、
異なるマシンで空白記号が共有されているかのような議論が多かったため、ここでは固定した。
空白記号を含めて定義する場合、基点付き集合として記号の集合を定義するのが良いかもしれない。

> **definition** 次の組をチューリングマシンと言う。
> - \(\Sigma\) : \(\mathbb{B}\) を含む有限集合...この集合の元を記号という
> - \(Q\): 有限集合...この集合の元を状態という
> - \(q_{\text{init}}\): \(Q\) の元...これを開始状態という
> - \(Q_{\text{fin}}\): \(Q\) の部分集合...この集合の元を終了状態という
> - \(\delta\): \((Q - Q_{\text{fin}}) \times \Sigma\) から \(Q \times \Sigma \times \{L,R,C\}\) への部分関数

Turing machine \(M\) に対して、 \(\Sigma_M\) や \(M.\Sigma\) など添え字やドットを付けることで、 \(M\) の構成要素のうち対応するものをあらわすことにする。
また、チューリングマシンの定義のうち特に \(\Sigma\) を固定して話すことが多いから、与えられた \(\Sigma\) に対して、チューリングマシン \(M\) であって \(\Sigma_M = \Sigma\) となる \(M\) を \(\Sigma\) 上のチューリングマシンと呼ぶことにする。

ここで、 \(\delta\) は部分関数であるから、（集合を用いた定義を考えると） \((Q - Q_{\text{fin}}) \times \Sigma \times Q \times \Sigma \times \{L,R,C\}\) の部分集合とみなせる。
この関数の元 \((q, \sigma, q^\prime, \sigma^\prime, D)\) をエントリと呼ぶことにする。

**Note**
チューリングマシンの他の定義には次のものがある。
- \(\Sigma\) の部分集合としてさらに \(\Gamma\) なる"入力記号の集合"を指定する
- \(\delta\) の定義を全域関数とする。これについては後にフォローを行う。
- \(\delta\) の値域を \(Q \times \Sigma \times \{L,R\}\) とする。
- \(\delta\) の値域を \(Q \times \Sigma \sqcup Q \times \{L,R,C\}\) とする。
- 終了状態の集合 \(Q_{\text{fin}}\)ではなく終了状態 \(q_{\text{fin}} \in Q\) を指定する。

### チューリングマシンが操作するものの定義
今、集合 \(\Sigma\) に対して（ \(\Sigma\) 上の）テープと呼ばれるものを考える。
このテープとは、各セルに \(\Sigma\) の元が格納されたものが左右無限に並んだもののことを言う。
ただし、テープの中の有限個のセルを除いて、セルは基本的に（先ほど固定した空白記号） \(\mathbb{B}\) が入っているものとする。
さらに、このテープには制御部と呼ばれるものがついていて、セルのうちの一つを指し示している。
あまり使わないかもしれないが、 \(\Sigma\) 上のテープ全体を \(\text{Tape}T\) と書くことにする。

このテープに対しては次のような操作を行うことができる。
- テープ \(T\) に対して、制御部を一つ右（ resp. 左）に動かしたテープを表す... \(\text{R} T\) （ resp. \(\text{L} T\) ）
- \(CT = T\) とする。
- テープ \(T\) に対して、制御部の指し示すセルの中身の記号を取り出す... \(\text{Head} T\)
- テープ \(T\) と \(s \in \Sigma\) に対して、制御部の指し示すセルの中身を \(s\) で書き換える... \(\text{Write} (T, s)\)

テープには制御部が付いていることにより、単に記号列が並んだものよりも情報が豊富である。

> **Note**
> テープの数学的な定義を形式的に書いているものはほとんどなかった（列の組のように書いているものはあるかもしれない）。
> 一応次の二つの定義が考えられる。
> - 整数の集合 \(\mathbb{Z}\) から \(\Sigma\) への写像であって \(\Sigma - \{\mathbb{B}\}\) の逆像が有限集合になっているものと \(q \in Q\) の組のこと。
>  制御部は \(0 \in \mathbb{Z}\) を指し、状態 \(q\) を保持している。
> - 自然数 \(i\) と、 \(\{1 \ldots i\}\) から \(\Sigma\) への写像であって先ほどと同様の条件を満たすものと、 \(l \in \{1 \ldots i\}\) の組のこと。制御部は \(l\) を指し、状態 \(q\) を保持している。
> - \(\Sigma\) 上の語と呼ばれる \(\Sigma\) の元を"有限個並べた"集合 \(\Sigma^*\) を許容すれば、テープは単に \(\Sigma^* \times \Sigma^*\) や \(\Sigma^* \Sigma \times \Sigma^*\) と書ける。ただし、"有限個並べる"の定義はプリミティブな操作とみなされるか、自然数 \(l\) と \(\{1 \ldots l} \to \Sigma\) の組として定義されるだろう。
> 
> なんにせよ、ここで重要なのは \(\text{R} T\) ・ \(\text{L} T\) ・ \(\text{Head} T\) ・ \(\text{Write}(T, s)\) といった操作を行えることである。
> また、テープの定義には \(\Sigma\) が表れるのだが、テープと書いている本が多い。
> ここでは、 \(\Sigma\) 上の、と書くことでテープの定義に言及できるようにした。
> ただしい用語かはわからない。

が、これではテープの指定の仕方がわからないので、とりあえず次の取り組みをしておく。

> **definition**
> \(l, r \in \Sigma^*\) と \(h \in \Sigma\) に対して、 \((l,h,r)\) を \(\text{Tape} \Sigma\) の元とみなす。
> 具体的には、制御部の指示している記号が \(h\) であり、制御部より左には \(l\) 、 制御部より右には \(r\) が並んでいるものとする。

さらに、制御部は状態 \(Q\) 上の元を一つ保持している。
（一般には、テープと有限制御部の組をテープと呼ぶことが多い。）

**Note**
状態 \(Q\) の元を保持しているということはテープの定義は \(\Sigma\) と \(Q\) を固定するごとに定まるはずである。
そのため、テープの定義自体を \(\Sigma, Q\) を固定してから述べるものも多いが、ここではテープを \(\Sigma\) 上で定義した。
制御部は \(Q\) の元を一つ保持しているというのは、 \(\text{Tape} \Sigma \times Q\) の元を選んでいるという風に考えればよい。

こうして得られる \(\text{Tape}\Sigma \times Q\) の元を計算状況と呼ぶ。

### チューリングマシンの計算の定義
チューリングマシンの計算は遷移関数を用いてテープと状態を変化させていくことで得られる。
> **definition**
> - チューリングマシン \(M = (\Sigma, Q, q_{\text{init}}, Q_{\text{fin}}, \delta)\) を固定する。
> - 計算状況 \((T, q)\) に対して、\((q, \text{Head} T, q^\prime, \sigma, D) \in \delta\) となるエントリがある場合、計算動作と呼び \((T,q) \rightarrow_{M} (D \text{Write}(T, \sigma), q^\prime)\) のように書く。
> - そのようなエントリがない場合、停止していると言い、 \(q \in Q_{\text{fin}}\) のとき正常停止と呼ぶ。
> - 計算動作の列 \((T_0, q_0) \rightarrow_{M} (T_1, q_1) \rightarrow_{M} \cdots \rightarrow_{M} (T_n, q_n)\) を計算列と呼ぶ。
> - テープ \(T\) に対して \(P_0 = (T, q_{\text{fin}})\) から始まる計算列 \(P_0 \rightarrow_{M} \cdots \rightarrow_{M} P_n\) であって \(P_n\) が停止しているものを計算過程と呼ぶ。
> - テープ \(T\) と \(T^\prime\) に対して、ある \(q\) であって \(P_n = (q, T^\prime)\) が最後となる計算過程が存在するとき、 \(T \rightarrow^{M} T^\prime\) と書く。

計算が定義されたことから、２つのチューリングマシンが同じ計算を行っているかどうかを以下のように定義する。
> **definition**
> - \(M_i = (\Sigma, Q_i, q_{\text{init}}^i, Q_{\text{fin}}^i, \delta^i)\) をとる。
> - \(M_1 \sim_{\text{eq}} M_2\) を、任意の \(\Sigma\) 上のテープ \(T\) と \(T^\prime\) に対して、 \(T \rightarrow^{M_1} T^\prime \Leftrightarrow T \rightarrow^{M_2} T^\prime\) が成り立つことと定義する。

> **Note**
> チューリングマシンの定義に \(Q_{\text{fin}}\) という集合を採用したことにより、我々の定義の場合は単に計算が（正常に）停止しているかといった情報だけではなく、どのような状態で停止しているのかという情報もまた含まれていることに注意したい。
> 特に、チューリングマシンをテープを受け取りテープを返す関数としてだけ見ているよりは情報が簡単に得られる。
> ただし、終了状態が一つしかないような定義を採用した場合も、テープに終了状態に対応するものを書き込むことで、以降行うことに対しても我々の定義と同様の操作を行うことができる。

今、考えたい"計算"があったとして、次のように形式化を定めることでチューリングマシンによる計算ととらえることができる。
- 考えたい計算を形式化する：例えば集合 \(A\) から \(B\) への部分関数 \(f\) とする。
- 二つの集合 \(A\) と \(B\) に対して、適切な符号の集合 \(\Sigma\) と符号化を選ぶ：\(A\) や \(B\) の \(\Sigma\) 上のテープ全体への埋め込み（\(\bar{a}\) や \(\bar{b}\) と書く）を固定する。
- よい条件を満たすチューリングマシン \(M\) を構成する：条件とは、
    - \(a \in A\) に対して、\(f(a)\) が存在すれば、 \(\bar{a}\) の正常停止する計算過程が存在して最後の計算状況が \((\bar{f(b)}, \_)\) になっている。
    - \(a \in A\) に対して \(\bar{a}\) の正常停止する計算過程が存在して最後の計算状況が \((T, \_)\) になっていれば、 \(f(a)\) が存在して \(T = \bar{f(a)}\) が成り立つ。

> **Note**
> 符号化を選ぶ必要があることに注意する。
> 記号の集合 \(\Sigma\) は有限集合であると決まっているので、例えば自然数上の関数をエミュレートするには \(\Sigma\) として単に自然数全体をとることはできない。
> また、符号化のとり方自体も複数ありうることがある。例えば、自然数の \(\Sigma = \{\mathbb{B}, 0,1\}\) 上のテープへの符号化として、二進数表示を行う以外に \(0\) を使わずに \(1\) を自然数の大きさ分だけなられる方法も考えられる。

> **疑問**
> 計算可能な自然数の全体って明らかに符号化のとり方による。
> 符号化のとり方自体を"計算可能"なものに限りたいわけだが、その議論は初めにとった符号化のとり方によってしまう。
> 腑に落ちない。

## 具体例
二進数で書かれた自然数に1を足すマシンを作ってみる。
考え方としては、下の桁から線形に見て行けばよい。
\(q_{\text{init}}\) から左に行き、 \(0\) が出てきたら \(1\) に書き換えて終わる。
\(1\) が出てきたら \(0\) に書き換えて、さらに繰り上がりモードを継続する。

遷移関数は次のようにすればいい（もっと簡単にできるはず）。

| key_sign | key_state | value_sign | value_state | value_direction |
| --- | --- | --- | --- | --- |
| - | start | - | add_1| L |
| 0| add_0| 0| add_0| L |
| 1| add_0| 1| add_0| L |
| 0| add_1| 1| add_0| L |
| 1| add_1| 0| add_1| L |
| -| add_0| -| end| C |
| -| add_1| 1| write| L |
|  | write| -| end| L |

ここでは記号や状態、初期状態と終了状態を省略した。
実際に動いているサンプルは以下である。

<component id="turing_machine_example2">

## チューリングマシンの構成
チューリングマシンの構成のために考察を行う。

### 単体のチューリングマシンに対する操作
チューリングマシン \(M = (\Sigma, Q, q_{\text{init}}, Q_{\text{fin}}, \delta)\) を固定する。

> **theorem**
> - \(\Sigma \subset \Sigma^\prime\) となる \(\Sigma^\prime\) があるとする。
> - \((\Sigma^\prime, Q, q_{\text{init}}, Q_{\text{fin}}, \delta)\) はチューリングマシンである。

\(\delta\) は \(\Sigma^\prime - \Sigma\) の元が入力されると（正常でない）停止をすることに注意する。
これを用いて、 \(M\) とその拡張を同一視することがある。

> **theorem**
> - \(f\): bijection of \(Q \to Q^\prime\) があるとする。
> - \(\delta^\prime\): \(Q^\prime - f(Q_{\text{fin}}) \times \Sigma \to Q^\prime \times \Sigma \times \{L,R,C\}\) を \((q, s) \mapsto (f \times 1 \times 1) \delta(f^{-1}q, s)\) とする。
> - \((\Sigma, Q^\prime, f(q_{\text{init}}), f(Q_{\text{fin}}), \delta^\prime)\) はチューリングマシンである。

ここでは、 \(\Sigma\) や \(Q\) を変形するような操作をチューリングマシンにしたが、チューリングマシンの行う計算の"本質"は変わっていないことに注意したい。
ただし、計算の"本質"が何であるかは全く議論をしていない。

### 

次に、チューリングマシンをつなげる構成について述べる。
2 つのチューリングマシン \(M_1, M_2\) があったとき、 \(M_1\) を行った後 \(M_2\) を行うチューリングマシンを作りたい。
単に、状態や遷移関数を（集合として）合併した場合、望むような動作ができない。
次のように仮定がある場合には適当な合併によりできる。

> **theorem**
> - \(M_i = (\Sigma_i, Q_i, {q_{\text{init}}}^i, {Q_{\text{fin}}}^i, \delta_i)\) をチューリングマシンとする。
> - \(\Sigma_1 = \Sigma_2 = \Sigma\), \(Q_1 \cap Q_2 = \emptyset\) を仮定する。
> - \(q \in Q_{\text{fin}}^1\) を選ぶ。
> - \(Q = Q_1 \sqcup Q_2\) とする。
> - \(Q_{\text{fin}} = Q_{\text{fin}}^1 \sqcup Q_{\text{fin}}^2 - \{q\}\) とする。
> - \(\delta = \delta_1 \cup \delta_2 \cup (\delta_{\text{glue}} = \{(q, s, {q_{\text{init}}}^2, s, C) \mid s \in \Sigma\})\) とする。
> - \((\Sigma, Q, {q_{\text{init}}}^1, Q_{\text{fin}}, \delta)\) はチューリングマシンである。

証明を行う。
- \(\delta^\prime\) の定義域と値域が \((Q - Q_{\text{fin}}) \times \Sigma \to Q \times \Sigma \times \{L,R,C\}\) におさまっているかどうかを確かめる。
    - 値域については \(\text{Im} \delta = \text{Im} \delta_1 \cup \text{Im} \delta^2 \cup \{q_{\text{init}}^2\} \times \Sigma \times \{L,R,C\}\) から正しい。
    - 定義については、 \(Q - Q_{\text{fin}} = (\sqcup (Q_1 - Q_{\text{fin}}^1)) \cup \{q\}\) に注意すると、 \(\text{dom} \delta = \text{dom}\delta_1 \cup \text{dom} \delta_2 \cup \{q\} \times \Sigma \subset Q_1 - Q_{\text{fin}}^1 \times \Sigma \cup Q_2 - Q_{\text{fin}}^2 \times \Sigma \cup \{q\} \times \Sigma = Q - Q_{\text{fin}} \times \Sigma\) よいよい。
- \(\delta\) が部分関数になっているかを確かめる。
    - 確認するのは \((q, s, \_, \_, \_) \in \delta\) が \((q,s)\) に対して高々一つしかないことである。
    - \(\delta_1, \delta_2 \delta_{\text{glue}}\) の値域がそれぞれ交わらないことに注意すればわかる。

いまこうして作られるチューリングマシンを \(M_1 \rightarrow_{s} M_2\) のように書く。
もし仮定が満たされていない場合でも、 \(\Sigma_i\) をそれぞれ適当に拡張して、 \(Q_i\) がそれぞれ交わらないように取り替えることで、全てのチューリングマシンに対してこの構成を行うことができる。
と、より一般に、グラフへの拡張を行うことができることが想像できる。
グラフの上のチューリングマシンがあり、各辺に状態がのっているものを考え、そこからチューリングマシンを作りたい。
グラフ \((V,E)\) の辺 \(e \in E\) に対して、その始点を \(\text{sr} e\) 終点を \(\text{tr} e\) と書く。

> **definition**
> - 次のものを固定し、あるいは仮定する。
>   - \((V, E)\) :有限な有向グラフ
>   - \(v_{\text{init}}\) : \(V\)
>   - \(M_v = (\Sigma_v, Q_v, q_{\text{init}}^v, Q_{\text{fin}}^v, \delta_v)\): 各 \(v \in V\) に対してチューリングマシンを与える関数
>   - \(S_e\): 各 \(e \in E\) に対してその辺の始点に対応するチューリングマシンの終了状態の一つをあたえる関数
>   - \(\Sigma_v = \Sigma_{v^\prime}\) forall \(v, v^\prime \in V\) (\(\Sigma\) と書くことにする。)
>   - \(Q_v \cap Q_{v^\prime} = \emptyset\) if \(v \not = v^\prime\)
> - 以下を与える。
>   - \(Q = (\bigcup_{v \in V} Q_v)\)
>   - \(q_{\text{init}} = q_{\text{init}}^{v_{\text{init}}}\)
>   - \(Q_{\text{fin}} = {\bigcup_{v \in V} Q_{\text{fin}}^{v}} - \bigcup_{e \in E} Q_e\)
>   - \(\delta = (\bigcup_{v \in V} \delta_v) \cup \{(S_e, s, q_{\text{init}}^{\text{tr} e}, s, C) \mid e \in E, s \in \Sigma\}\)
> - \((\Sigma, Q, q_{\text{init}}, Q_{\text{fin}}, \delta)\) はチューリングマシンである。

証明は似たような感じでできると思う。

いくつか観察を行いたい。

辺の始点と終点が一致している場合も許容されていることに注目する。
例えば頂点が１つ、辺が１つのグラフ \((\{v\}, \{e\})\) にチューリングマシン \(M\) と状態 \(q \in Q_{\text{fin}}\) がのっているとする。
このとき、得られるチューリングマシンの遷移関数は \((q, s, q_{\text{init}}, s, C)\) だけ増えているから、もともとのチューリングマシンで \(q\) で停止するような計算があったとき、新しく得られたチューリングマシンはもう一度テープに計算を施すことがわかる。
さらに、施した結果が \(q\) で停止した場合にはもう一度テープに計算を施すから、結果として、 \(q\) で停止しなくなるまで永遠に計算し続けるものが得られる。
ここで対比として \(M \rightarrow_{q} M\) を考える。
（ただし、「もし仮定が満たされていない場合でも」に対応していることに注意する。）
\(\rightarrow\) を使った場合は \(q\) で一度停止した場合は確かにもう一度 \(M\) による計算を行うが、再度 \(q\) が出た場合はそこで停止する。

> **疑問**
> 多分、グラフに対して一気にチューリングマシンを作るのと、辺ごとにチューリングマシンをくっつけていったものとでは同値になるのではないか？

このグラフの構成についても、仮定を満たしていないようなチューリングマシンがくっついている場合にも、適切に記号 \(\Sigma\) を拡張したり状態 \(Q\) を重ならないように動かしたりすることで、"計算"行為を保ったまま構成ができる。

> **note**
> \(M_1 \sim_{\text{eq}} M_2\) のような関係に対してはグラフ上のチューリングマシンを単に取り換えることができないことに注意する。
> \(\sim_{\text{eq}}\) を状態の移りあいを考慮して定義することが必要である。

## チューリングマシンができること：計算可能な自然数の関数について
自然数の符号化を固定して、チューリングマシンの計算できる自然数関数がどれぐらいなのかを見積もる。

### 符号化の定義
以降では \(\Sigma = \{\mathbb{B}, 1, -\}\) とする。
また、自然数全体を \(\mathbb{N}\) とし、 \(0\) を含めるものとする。

> **definition**
> - \(n \in \mathbb{N}\) に対して、 \(\bar{n} \in \Sigma^*\) を \(1\) を \(n\) 個並べたものとする。
> - \(k \in \mathbb{N}\) と \(p = (n_1, \ldots, n_k) \in \mathbb{N}^k\) に対して、 \(\tilde{p} \in \text{Tape} \Sigma\) を \((\emptyset, -, \mathbb{B} \bar{n_1} \mathbb{B} \bar{n_2} \mathbb{B} \cdots \mathbb{B} \bar{n_k} -)\) とする。
> - \(-\) ではさまれた中に \(k\) 個の \(\mathbb{B}\) がある。
> - 逆に、 \(T \in \text{Tape} \Sigma\) に対して、 \(\Phi(T) \in (\bigsqcup_{k} \mathbb{N}^k) \sqcup \{\text{undefined}\}\) を、
>   - 自然数のペア \(p\) であって \(\tilde{p} = T\) となるものがあるとき \(\phi(T) = p\)
>   - そうでないとき \(\phi(T) = \text{undefined}\) とする。

### チューリングマシンの計算する関数
こうしてテープの解釈が定まったので、自然数関数を計算するマシンの定義ができる。
\(n\) 引数の関数とは \(\mathbb{N}^n \to \mathbb{N}\) のことである。

> **definition**
> - \(f\): \(\mathbb{N}^k\) から \(\mathbb{N}\) への部分関数とする。
> - \(M\): \(\Sigma\) 上のTuring machine とする。
> - \(M\) が \(f\) を計算するとは、任意の \(p \in \text{Dom} f\) に対してある \(T^\prime\) が存在して \(\tilde{p} \rightarrow^{M} T^\prime\) かつ \(\phi(T) = f(p)\) がなりたつことをいう

ここでは条件に含まれないが、おそらく、一般には \(\tilde{p} \rightarrow^{M} T^\prime\) となる \(T^\prime\) が存在する場合には \(p \in \text{Dom} f\) かつ \(\phi(T) = f(p)\) となることも条件に含まれている。
すなわち、チューリングマシンが停止するような計算が \(f\) の対応と必ず一対一に対応していることが課される。
ここではそのような条件は課していない。

### 再帰的関数
この節では再帰関数と呼ばれる関数たちを定義する。

> **definition**
> 次のような帰納的定義で定義される自然数関数のクラスを再帰関数と呼ぶ。
> - 次の関数は自然数関数である
>   - ゼロ定数関数 \(() \in \mathbb{N}^0 \mapsto 0 \in \mathbb{N}\)
>   - 後者関数 \(n \in \mathbb{N}^1 \mapsto n+1 \in \mathbb{N}\)
>   - \(k\) 引数の \(i\) 番目への射影関数 \((n_1, \ldots, n_k) \in \mathbb{N}^k \mapsto n_i \in \mathbb{N}\)
> - 次のようにして得られる合成関数は再帰関数である
>   - \(f\): \(n\) 引数の再帰関数, \(g_0, \ldots g_n\): 全て \(m\) 引数の再帰関数をとる
>   - 合成関数 \((x_1, \ldots, x_m) \in \mathbb{N}^m \mapsto f(g_0(x_1, \ldots, x_m), \ldots g_n(x_1, \ldots, x_m)) \in \mathbb{N}\)
> - 次のようにして得られる原始再帰関数は再帰関数である
>   - \(f\): \(n\) 引数の再帰関数, \(g\): \(n+2\) 引数の再帰関数をとる
>   - 原子再帰関数 \(h (x_0, x_1, \ldots, x_n) =\)
>       - \(x_0 = 0\) のとき \(f(x_1, \ldots, x_n)\)
>       - \(x_0 = 1 + x\) のとき \(g(h(x, x_1, \ldots x_n), x_1, \ldots, x_n)\)
> - 次のようにして得られる \(\mu\) 再帰関数は再帰関数である
>   - \(f\): \(n+1\) 引数の再帰関数をとる
>   - \((\mu f)(x_1, \ldots, x_n) = \text{min} \{y \in \mathbb{N} \mid f(y, x_1, \ldots, x_n) = 0\}\)

### 再帰関数の計算可能性
再帰関数は計算可能であることを示す。
ここで用いるチューリングマシンは二種類ある。
- 再帰関数を実際に計算する
- 補助的な動きをする
ここで、再帰関数を実際に計算するマシンは、「最初に受け取ったテープの左側にはいかなる計算状況においても変更しないし見に行かない」（＊）ものとする。
これを仮定することで扱いやすくなる。

#### 基本関数を計算するマシン
ゼロ定数関数は \(\tilde{()} = (\mathbb{B}, -, -)\) をうけとり \(\tilde{(0)} = (\mathbb{B}, -, \mathbb{B} -)\) を返すようになっていればよい。
後者関数は \(\tilde{(n)} = (\mathbb{B}, -, \mathbb{B} \bar{n} -)\) をうけとり \(\tilde{(n+1)} = (\mathbb{B}, -, \mathbb{B} \bar{n+1}) -\) を返すようになっていればよい。
射影関数は \(\tilde{(n_1, \ldots, n_k)} = (\mathbb{B}, -, \mathbb{B} \bar{n_1} \mathbb{B} \cdots \mathbb{B} \bar{n_k} -)\) をうけとり \(\tilde{(n_i)} = (-, \mathbb{B}, -, \mathbb{B} \bar{n_i} -)\) を返すようになっていればよい。
これらは簡単に作れるし、（＊）の条件を満たすように作れることがわかる。
実際に作ったものが以下になる。

<component id="turing_machine_basic">

#### 補助的な関数を計算するマシン
合成関数に対応するマシンを計算するにあたり、
次のマシンがあるとよい。
- copying: \((X, -, \bar{p} - Y)\) を受け取って \((X - \bar{p}, -, \bar{p} - Y)\) を返す。
- swaping: \((X, -, \bar{p_1} - \bar{p_2} - Y)\) を受け取って \((X, -, \bar{p_2} - \bar{p_1} - Y)\) を返す。
- moveing: \(-\) のある部分に注目し左か右に行く。
