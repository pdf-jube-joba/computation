# チューリングマシンができること：計算可能な自然数の関数について
自然数の符号化を固定して、チューリングマシンの計算できる自然数関数がどれぐらいなのかを見積もる。
ここでは具体的に、再帰関数と呼ばれるクラスを定義し、その関数がすべてチューリングマシンで計算可能であることを示す。

自然数全体を \(\mathbb{N}\) と書き、 \(0\) を含めるものとする。

## 再帰的関数
この節では再帰関数と呼ばれる関数たちを定義する。

> **definition**
> 次のような帰納的定義で定義される、自然数の組を受け取り自然数を返す"全域"関数のクラスを再帰関数と呼ぶ。
> - 次の関数は自然数関数である
>   - ゼロ定数関数 \(() \in \mathbb{N}^0 \mapsto 0 \in \mathbb{N}\)
>   - 後者関数 \(n \in \mathbb{N}^1 \mapsto n+1 \in \mathbb{N}\)
>   - \(k\) 引数の \(i\) 番目への射影関数 \((n_1, \ldots, n_k) \in \mathbb{N}^k \mapsto n_i \in \mathbb{N}\)
> - 次のようにして得られる合成関数は再帰関数である
>   - \(f\): \(n\) 引数の再帰関数, \(g_1, \ldots g_n\): 全て \(m\) 引数の再帰関数をとる
>   - 合成関数 \((x_1, \ldots, x_m) \in \mathbb{N}^m \mapsto f(g_0(x_1, \ldots, x_m), \ldots g_n(x_1, \ldots, x_m)) \in \mathbb{N}\)
> - 次のようにして得られる原始再帰関数は再帰関数である
>   - \(f\): \(n\) 引数の再帰関数, \(g\): \(n+2\) 引数の再帰関数をとる
>   - 原始再帰関数 \(h (x_0, x_1, \ldots, x_n) =\)
>       - \(x_0 = 0\) のとき \(f(x_1, \ldots, x_n)\)
>       - \(x_0 = 1 + x\) のとき \(g(h(x, x_1, \ldots x_n), x_1, \ldots, x_n)\)
> - 次のようにして得られる \(\mu\) 再帰関数のうち、"全域関数となる"関数は再帰関数である
>   - \(f\): \(n+1\) 引数の再帰関数をとる
>   - \((\mu f)(x_1, \ldots, x_n) = \text{min} \{y \in \mathbb{N} \mid f(y, x_1, \ldots, x_n) = 0\}\)

例としては恒等写像、足し算、掛け算などの基本的な関数は当然含まれる。
\(\mu\) 再帰関数を用いて定義される関数の例として、アッカーマン関数と呼ばれるものがある。
このアッカーマン関数 \(A(m,n)\) は、

- \(A(0, n) = n + 1\)
- \(A(n, 0) = A(n-1, 1)\)
- \(A(n, m) = A(m-1, A(m, n-1))\)

のようにして関数としては定義されているが、これを上のような形に書き直すことができる。
WIP

> **Remark**
> 全域な再帰関数に対して単純に \(\mu\) 再帰を用いても、全域な関数が得られるとは限らない。
> 例えば、足し算から \(\mu\) 再帰により得られる関数は \(\text{min}\) に与えられる集合が空となりえることから全域でない。
> また、帰納的定義の仕方が異なっていたとしても同じ写像を定めていることがありえる。
> 例えば、 monus とも呼ばれる引き算に似た写像
>（ \(m\) > \(n\) のときは \(m- n\) とし、そうでないときは \(0\) とすることで引き算の結果を自然数に拡張したもの）
> から \(\mu\) 再帰によりえられる関数は、\(x \mapsto 0\) なる写像であり、
> ゼロ定数関数と空 \(m \mapsto ()\) の合成関数としても得ることができる。

## 符号化の定義
この説では、チューリングマシンの計算可能な関数を考えるため、自然数の符号化を述べる。
以降では \(\Sigma = \{\mathbb{B}, 1, -\}\) とする。

> **definition**
> - \(n \in \mathbb{N}\) に対して、 \(\bar{n} \in \Sigma^*\) を \(1\) を \(n\) 個並べたものとする。
> - \(k \in \mathbb{N}\) と \(p = (n_1, \ldots, n_k) \in \mathbb{N}^k\) に対して、 \(\tilde{p} \in \text{Tape} \Sigma\) を \((\emptyset, -, \mathbb{B} \bar{n_1} \mathbb{B} \bar{n_2} \mathbb{B} \cdots \mathbb{B} \bar{n_k} -)\) とする。
> - \(-\) ではさまれた中に \(k\) 個の \(\mathbb{B}\) がある。
> - 逆に、 \(T \in \text{Tape} \Sigma\) に対して、 \(\Phi(T) \in (\bigsqcup_{k} \mathbb{N}^k) \sqcup \{\text{undefined}\}\) を、
>   - 自然数のペア \(p\) であって \(\tilde{p} = T\) となるものがあるとき \(\phi(T) = p\)
>   - そうでないとき \(\phi(T) = \text{undefined}\) とする。

## チューリングマシンの計算する関数
こうしてテープの解釈が定まったので、自然数関数を計算するマシンの定義ができる。
\(n\) 引数の関数とは \(\mathbb{N}^n \to \mathbb{N}\) のことである。

> **definition**
> - \(f\): \(\mathbb{N}^k\) から \(\mathbb{N}\) への部分関数とする。
> - \(M\): \(\Sigma\) 上のTuring machine とする。
> - \(M\) が \(f\) を計算するとは、任意の \(p \in \text{Dom} f\) に対してある \(T^\prime\) が存在して \(\tilde{p} \rightarrow^{M} T^\prime\) かつ \(\phi(T) = f(p)\) がなりたつことをいう

ここでは条件に含まれないが、おそらく、一般には \(\tilde{p} \rightarrow^{M} T^\prime\) となる \(T^\prime\) が存在する場合には \(p \in \text{Dom} f\) かつ \(\phi(T) = f(p)\) となることも条件に含まれている。
すなわち、チューリングマシンが停止するような計算が \(f\) の対応と必ず一対一に対応していることが課される。
ここではそのような条件は課していない。

## 再帰関数の計算可能性
再帰関数は計算可能であることを示す。
ここで用いるチューリングマシンは二種類ある。
- 再帰関数を実際に計算する
- 補助的な動きをする
ここで、再帰関数を実際に計算するマシンは、「最初に受け取ったテープの左側にはいかなる計算状況においても変更しないし見に行かない」（＊）ものとする。
これを仮定することで扱いやすくなる。

### 基本関数を計算するマシン
ゼロ定数関数は \(\tilde{()} = (\mathbb{B}, -, -)\) をうけとり \(\tilde{(0)} = (\mathbb{B}, -, \mathbb{B} -)\) を返すようになっていればよい。
後者関数は \(\tilde{(n)} = (\mathbb{B}, -, \mathbb{B} \bar{n} -)\) をうけとり \(\tilde{(n+1)} = (\mathbb{B}, -, \mathbb{B} \bar{n+1}) -\) を返すようになっていればよい。
射影関数は \(\tilde{(n_1, \ldots, n_k)} = (\mathbb{B}, -, \mathbb{B} \bar{n_1} \mathbb{B} \cdots \mathbb{B} \bar{n_k} -)\) をうけとり \(\tilde{(n_i)} = (-, \mathbb{B}, -, \mathbb{B} \bar{n_i} -)\) を返すようになっていればよい。
これらは簡単に作れるし、（＊）の条件を満たすように作れることがわかる。
実際に作ったものが以下になる。

<component id="turing_machine_basic">

### 補助的なマシン
合成関数に対応するマシンを計算するにあたり、
次のマシンがあるとよい。
- \(n\)-times-copy: \((X, -, \bar{p} - b...)\) を受け取って \((X, -, \bar{p} - ... - \bar{p} - b...)\) を返す。
- rotate: \((X, -, \bar{p_1} - ... -\bar{p_n} -b...)\) を受け取って \((X, -, \bar{p_2} - \bar{p_3} - ... - \bar{p_n} - \bar{p_1} -b...)\) を返す。
- move: \(-\) のある部分に注目し左か右に行く。

### 合成関数
合成関数については次のような順序で呼ぶ。
マシンを \(M_1, \ldots, M_n\) 及び \(M\) と用意する。
受け取るのは \((X, -, p-)\) である。

- \((X, -, p-...-p-)\) のように \(p\) を \(n\) 個コピーする。
- 一番右側の \(p\) の位置へ行き、 \(M_1\) を呼び、戻ってくる。（ \((X, -, p-...-M_1(p)-)\) となる。）
- ローテーションを行う。 （ \((X, -, p-...-M_1(p)-p- )\) となる。）
- 一番右側の \(p\) の位置へ行き、 \(M_2\) を呼び、戻ってくる。（ \((X, -, p-...-M_1(p)-M_2(p)-)\) となる。）
- ローテーションを行う。（ \((X, -, p-...-M_1(p)-M_2(p)-p-)\) となる。）
- これを続ける。
- 一番最後の \(M_n\) に対しても同様に、右側の \(p\) の位置へ行き、 \(M_n\) を呼び、戻ってくる。（ \((X, -, M_1(p)-...-M_n(p)-)\) となる。）
- 右側が \(-\) で区切られているため、これを除去してくっつける。（ \((X, -, M_1(p)M_2(p)...M_n(p)-)\) となる。）
- これに対して \(M\) を呼ぶ。

関数 \(f_1, \ldots, f_n\) 及び \(g\) に対して、それぞれを計算するマシン \(M_1, \ldots, M_n, M\) が与えられているとする。
上の方法で得られるマシンは \(g \circ (f_1, \ldots f_n)\) を計算する。
注意点として、これを"続ける"の部分はマシンが先に与えられていれば単に線形に操作を行うだけでよい。
これは後述する原始再帰関数の構成とは異なる。

### 原始再帰関数
原始再帰関数については次のような順序で呼ぶ。
マシンを \(M_0, M_1\) と用意する。
受け取るのは \((X, -, b\bar{x}p-)\) のようになっているとする。
重要な点として、 \(-1-\) のような並びは普通の自然数を表す目的で現れることはないから、これを目印にする。

- 右側に \(-1-\) を挿入する。（ \((X, -, 1-p-...-M_1(p)-)\) となる。）
- 右側を \(x\) の値を下げながらコピーし、 \(x = 0\) になったら \(p\) のみをコピーする。（ \((X, -, 1 - b\bar{x-1}p-b\bar{x-2}-...-bp-p-)\) となる。）
- 一番右側に行き、 \(M_0\) を呼ぶ。（ \((X, -, 1 - b\bar{x-1}p-b\bar{x-2}-...-bp-M_0(p)-)\) となる。）
- **もし** 左側が \(-1-\) の形をしていたら、 \(-1-\) を除去し間を詰めて終了する。（\((X- 1 ,-, M_0(p)-)\) となっていた場合なので  \((X, -, M_0(p)-)\) となる。）
- 一つ左へ行き、二つを入れ替えた後くっつける。（ \((X, -, 1 - b\bar{x-1}p-b\bar{x-2}-...-(1,p)-(M_0(p), 0, p))-\) となる。）
- \(M_1\) を呼び、 **もし** の部分に戻る。

合成関数と同じように、これも対応する原始関数を計算するマシンを構成している。
どんな大きさの引数が与えられるかマシンを得た段階ではわからないことから、
このマシンの構成にはループが含まれている。
ただし、初めに左側に \(-1-\) をつけたことと、右側から左に順々に畳みこんでいくことからこのループは（与えられたマシンが停止する場合には）必ず停止する。

### \(\mu\) 再帰関数
\(\mu\) 再帰関数については次のような順序で呼ぶ。
マシンを \(M\) と用意する。
受けとるのは \((X, -, p-)\) となっているとする。

- \((X, -, p-\bar{(0)}-)\) と変形する。
- \((X, -, p-\bar{(x)}-)\) となっているテープを \((X - p- \bar{(x)}, -, \bar{(x, p)} -)\) と変形する。
- \(M\) を呼ぶ
- もし右側が \(0\) かどうかを判定しつぎのように分岐する
    - \(0\) の場合、 \((X -p- \bar{(x)}, -,b-)\) となっているのだが、これを \((X, -, \bar{(x)} -)\) と変形し終了する
    - \(0\) でない場合には、右側を消し、左側に \(1\) を足して \((X, -, p-\bar{x+1}-)\) のように変形してから、上から二行目に戻る。

これも対応する \(\mu\) 再帰関数を計算している。
万が一与えられたマシンが与えられた入力に対して \(0\) を出力するような \(x\) を持たない場合、
このマシンは止まらない。

### 例

上三つの関数に対して、具体的に構成したチューリングマシンを以下においておく。
例は上から

- \(\text{succ} \circ (\text{proj}^3_0)\)
- 足し算
- 掛け算を用いた \(m \in \mathbb{N} \mapsto 0 \in \mathbb{N}\)

<component id="turing_machine_other">

