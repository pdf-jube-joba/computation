## チューリングマシンの構成
再帰関数の計算可能性の議論のために
チューリングマシンの構成について考察する。

### 単体のチューリングマシンに対する操作
議論を楽にするため（だけ）にいろいろ導入する。
チューリングマシン \(M = (\Sigma, Q, q_{\text{init}}, Q_{\text{fin}}, \delta)\) を固定する。

> **theorem**
> - \(\Sigma \subset \Sigma^\prime\) となる \(\Sigma^\prime\) があるとする。
> - \((\Sigma^\prime, Q, q_{\text{init}}, Q_{\text{fin}}, \delta)\) はチューリングマシンである。

\(\delta\) は \(\Sigma^\prime - \Sigma\) の元が入力されると（正常でない）停止をすることに注意する。
これを用いて、 \(M\) とその拡張を同一視することがある。

> **theorem**
> - \(f\): bijection of \(Q \to Q^\prime\) があるとする。
> - \(\delta^\prime\): \(Q^\prime - f(Q_{\text{fin}}) \times \Sigma \to Q^\prime \times \Sigma \times \{L,R,C\}\) を \((q, s) \mapsto (f \times 1 \times 1) \delta(f^{-1}q, s)\) とする。
> - \((\Sigma, Q^\prime, f(q_{\text{init}}), f(Q_{\text{fin}}), \delta^\prime)\) はチューリングマシンである。

> [!NOTE]
> ここでは、 \(\Sigma\) や \(Q\) を変形するような操作をチューリングマシンにしたが、
> チューリングマシンの行う計算の"本質"は変わっていないことに注意したい。
> （計算の"本質"が何であるかは全く議論をしていないが）

これでいつでも必要に応じてチューリングマシンを（その計算内容を変えずに）取り替えることができる。

### チューリングマシンの連結

次に、チューリングマシンをつなげる構成について述べる。
2 つのチューリングマシン \(M_1, M_2\) があったとき、 \(M_1\) を行った後 \(M_2\) を行うチューリングマシンを作りたい。
単に、状態や遷移関数を（集合として）合併した場合、望むような動作ができない。
次のように仮定がある場合には適当な合併によりできる。

> **theorem**
> - \(M_i = (\Sigma_i, Q_i, {q_{\text{init}}}^i, {Q_{\text{fin}}}^i, \delta_i)\) をチューリングマシンとする。
> - \(\Sigma_1 = \Sigma_2 = \Sigma\), \(Q_1 \cap Q_2 = \emptyset\) を仮定する。
> - \(q \in Q_{\text{fin}}^1\) を選ぶ。
> - \(Q = Q_1 \sqcup Q_2\) とする。
> - \(Q_{\text{fin}} = Q_{\text{fin}}^1 \sqcup Q_{\text{fin}}^2 - \{q\}\) とする。
> - \(\delta = \delta_1 \cup \delta_2 \cup (\delta_{\text{glue}} = \{(q, s, {q_{\text{init}}}^2, s, C) \mid s \in \Sigma\})\) とする。
> - \((\Sigma, Q, {q_{\text{init}}}^1, Q_{\text{fin}}, \delta)\) はチューリングマシンである。

証明を行う。
- \(\delta^\prime\) の定義域と値域が \((Q - Q_{\text{fin}}) \times \Sigma \to Q \times \Sigma \times \{L,R,C\}\) におさまっているかどうかを確かめる。
    - 値域については \(\text{Im} \delta = \text{Im} \delta_1 \cup \text{Im} \delta^2 \cup \{q_{\text{init}}^2\} \times \Sigma \times \{L,R,C\}\) から正しい。
    - 定義については、 \(Q - Q_{\text{fin}} = (\sqcup (Q_1 - Q_{\text{fin}}^1)) \cup \{q\}\) に注意すると、 \(\text{dom} \delta = \text{dom}\delta_1 \cup \text{dom} \delta_2 \cup \{q\} \times \Sigma \subset Q_1 - Q_{\text{fin}}^1 \times \Sigma \cup Q_2 - Q_{\text{fin}}^2 \times \Sigma \cup \{q\} \times \Sigma = Q - Q_{\text{fin}} \times \Sigma\) よいよい。
- \(\delta\) が部分関数になっているかを確かめる。
    - 確認するのは \((q, s, q', s', d) \in \delta\) が \((q,s)\) に対して高々一つしかないことである。
    - \(\delta_1, \delta_2 \delta_{\text{glue}}\) の値域がそれぞれ交わらないことに注意すればわかる。

いまこうして作られるチューリングマシンを \(M_1 \rightarrow_{s} M_2\) のように書く。
もし仮定が満たされていない場合でも、 \(\Sigma_i\) をそれぞれ適当に拡張して、 \(Q_i\) がそれぞれ交わらないように取り替えることで、全てのチューリングマシンに対してこの構成を行うことができる。
と、より一般に、グラフへの拡張を行うことができることが想像できる。
グラフの上のチューリングマシンがあり、各辺に状態がのっているものを考え、そこからチューリングマシンを作りたい。
グラフ \((V,E)\) の辺 \(e \in E\) に対して、その始点を \(\text{sr} e\) 終点を \(\text{tr} e\) と書く。

チューリングマシンの連結
:   - 次のものが与えられているとする。
        - \((V, E)\) :有限な有向グラフ
        - \(v_{\text{init}}\) : \(V\)
        - \(M_v = (\Sigma_v, Q_v, q_{\text{init}}^v, Q_{\text{fin}}^v, \delta_v)\): 各 \(v \in V\) に対してチューリングマシンを与える関数
        - \(S_e\): 各 \(e \in E\) に対してその辺の始点に対応するチューリングマシンの終了状態の一つをあたえる関数
        - \(\Sigma_v = \Sigma_{v^\prime}\) forall \(v, v^\prime \in V\) (\(\Sigma\) と書くことにする。)
        - \(Q_v \cap Q_{v^\prime} = \emptyset\) if \(v \not = v^\prime\)
    - チューリングマシンの連結は次のように定義する。
        - \(Q = (\bigcup_{v \in V} Q_v)\)
        - \(q_{\text{init}} = q_{\text{init}}^{v_{\text{init}}}\)
        - \(Q_{\text{fin}} = {\bigcup_{v \in V} Q_{\text{fin}}^{v}} - \bigcup_{e \in E} Q_e\)
        - \(\delta = (\bigcup_{v \in V} \delta_v) \cup \{(S_e, s, q_{\text{init}}^{\text{tr} e}, s, C) \mid e \in E, s \in \Sigma\}\)
        - \((\Sigma, Q, q_{\text{init}}, Q_{\text{fin}}, \delta)\) はチューリングマシンである。

証明は似たような感じでできると思う。

いくつか観察を行いたい。

辺の始点と終点が一致している場合も許容されていることに注目する。
例えば頂点が１つ、辺が１つのグラフ \((\{v\}, \{e\})\) にチューリングマシン \(M\) と状態 \(q \in Q_{\text{fin}}\) がのっているとする。
このとき、得られるチューリングマシンの遷移関数は \((q, s, q_{\text{init}}, s, C)\) だけ増えているから、もともとのチューリングマシンで \(q\) で停止するような計算があったとき、新しく得られたチューリングマシンはもう一度テープに計算を施すことがわかる。

さらに、施した結果が \(q\) で停止した場合にはもう一度テープに計算を施すから、結果として、 \(q\) で停止しなくなるまで永遠に計算し続けるものが得られる。
ここで対比として \(M \rightarrow_{q} M\) を考える。
（ただし、「もし仮定が満たされていない場合でも」に対応していることに注意する。）
\(\rightarrow\) を使った場合は \(q\) で一度停止した場合は確かにもう一度 \(M\) による計算を行うが、再度 \(q\) が出た場合はそこで停止する。


このグラフの構成についても、仮定を満たしていないようなチューリングマシンがくっついている場合に、適切に記号 \(\Sigma\) を拡張したり状態 \(Q\) を重ならないように動かしたりすることで、"計算"行為を保ったまま構成ができる。

> [!Note]
> 多分、グラフに対して一気にチューリングマシンを作るのと、辺ごとにチューリングマシンをくっつけていったものとでは同値になるのではないか？
> \(M_1 \sim_{\text{eq}} M_2\) のような関係に対してはグラフ上のチューリングマシンを単に取り換えることができないことに注意する。
> \(\sim_{\text{eq}}\) を状態の移りあいを考慮して定義することが必要である。

## 再帰関数の計算
この節では、チューリングマシンの計算可能な関数を考えるため、自然数の符号化を述べる。
以降では \(\Sigma = \{\mathbb{B}, 1, -\}\) に加えて、必要に応じて文字を追加する。

自然数の符号化
: \(n \in \Nat\) に対して、 \(\overline{n} \in \Sigma^*\) を \(1\) を \(n\) 個並べたものとする。

自然数の tuple の符号化
: \(k \in \Nat\) と \(p = (n_1, \ldots, n_k) \in \Nat^k\) に対して、 \(\psi(p) \in \Sigma^*\) を \(- \mathbb{B} \overline{n_1} \mathbb{B} \overline{n_2} \mathbb{B} \cdots \mathbb{B} \overline{n_k} -\) とする。
 逆の操作 \(\phi: \Sigma^ * \to \Nat\) は常にできるわけではないので、そのような \(n\) が存在しない場合に備えて、 \(\phi\) の値域を拡張し、 \(\phi(T) = \text{undefined}\) とする。

\(\Sigma^*\) とテープの対応
: \(p \in \Nat^k\) に対して定義された \(\psi(p) \in \Sigma^*\) に対しては、これをテープと考えるときには、左は全部空白、ヘッドは \(-\) の位置としておく。

> [!Note]
> \(k\) 個の tuple の場合、 \(-\) ではさまれた中に \(k\) 個の \(\mathbb{B}\) があることがわかる。

> [!Warning]
> 全部壊れました。

### チューリングマシンの計算する関数
こうしてテープの解釈が定まったので、自然数関数を計算するマシンの定義ができる。
\(n\) 引数の関数とは \(\Nat^n \to \Nat\) のことである。

チューリングマシンにより計算可能な関数
: - \(f\): \(\Nat^k\) から \(\Nat\) への部分関数とする。
  - \(M\): \(\Sigma\) 上のTuring machine とする。
  - \(M\) が \(f\) を計算するとは、任意の \(p \in \text{Dom} f\) に対してある \(T^\prime\) が存在して \(\psi {p} \rightarrow^{M} T^\prime\) かつ \(\phi(T) = f(p)\) がなりたつことをいう

ここでは条件に含まれないが、おそらく、一般には \(\psi {p} \rightarrow^{M} T^\prime\) となる \(T^\prime\) が存在する場合には \(p \in \txtop{Dom} f\) かつ \(\phi(T) = f(p)\) となることも条件に含まれている。
すなわち、チューリングマシンが停止するような計算が \(f\) の対応と必ず一対一に対応していることが課される。
ここではそのような条件は課していない。

### 再帰関数の計算可能性
再帰関数は計算可能であることを示す。
ここで用いるチューリングマシンは二種類ある。
- 再帰関数を実際に計算する
- 補助的な動きをする

ここで、再帰関数を実際に計算するマシンは、「最初に受け取ったテープの左側にはいかなる計算状況においても変更しないし見に行かない」（＊）ものとする。
これを仮定することで扱いやすくなる。

### 基本関数を計算するマシン
ゼロ定数関数は \(\psi (()) = (\mathbb{B}, -, -)\)
をうけとり \(\psi ((0)) = (\mathbb{B}, -, \mathbb{B} -)\) を返すようになっていればよい。

後者関数は \(\psi ((n)) = (\mathbb{B}, -, \mathbb{B} \overline{n} -)\) をうけとり \(\psi {(n+1)} = (\mathbb{B}, -, \mathbb{B} \overline{n+1}) -\) を返すようになっていればよい。
射影関数は \(\psi {(n_1, \ldots, n_k)} = (\mathbb{B}, -, \mathbb{B} \overline{n_1} \mathbb{B} \cdots \mathbb{B} \overline{n_k} -)\) をうけとり \(\psi {(n_i)} = (\mathbb{B}, -, \mathbb{B} \overline{n_i} -)\) を返すようになっていればよい。
これらは簡単に作れるし、（＊）の条件を満たすように作れることがわかる。
実際に作ったものが以下になる。

### 補助的なマシン
合成関数に対応するマシンを計算するにあたり、
次のマシンがあるとよい。

\(n\)-times-copy
: \((X, -, \overline{p} - \mathbb{B}...)\) を受け取って \((X, -, \overline{p} - ... - \overline{p} - \mathbb{B}...)\) を返す。

rotate
: \((X, -, \overline{p_1} - ... -\overline{p_n} -\mathbb{B}...)\) を受け取って \((X, -, \overline{p_2} - \overline{p_3} - ... - \overline{p_n} - \overline{p_1} - \mathbb{B}...)\) を返す。

move
: \(-\) のある部分に注目し左か右に行く。

glue
: \((X, -, Y_1 - Y_2 -)\) を \((X, -, Y_1 Y_2 -)\) にする。

### 合成関数
合成関数については次のような順序で呼ぶ。
マシンを \(M_1, \ldots, M_n\) 及び \(M\) と用意する。
受け取るのは \((X, -, p-)\) である。

| やること | 結果（テープ） |
| --- | --- |
| \(p\) を \(n\) 個コピーする。 | \((X, -, p - \cdots - p -)\) |
| 1. 一番右側の \(p\) の位置へ行き <br> 2. \(M_1\) を呼び、 <br> 3. 戻ってくる。 | \((X, -, p-...-M_1(p)-)\) |
| ローテーションを行う。 | \((X, -, p-...-M_1(p)-p- )\) |
| 1. 一番右側の \(p\) の位置へ行き <br> \(M_2\) を呼び、 <br> 3. 戻ってくる。| \((X, -, p-...-M_1(p)-M_2(p)-)\) |
| ローテーションを行う。 | \((X, -, p-...-M_1(p)-M_2(p)-p-)\)  |
| これを続ける | \(\ldots\) |
| 一番最後の \(M_n\) に対しても同様にする。 | \((X, -, M_1(p)-...-M_n(p)-)\) |
| 右側が \(-\) で区切られているため、 glue を利用してこれを除去する。 | \((X, -, M_1(p)M_2(p)...M_n(p)-)\) |
| これに対して \(M\) を呼ぶ。 | \((X, -, M(M_1(p), \ldots, M_n(p)) -)\) |

関数 \(f_1, \ldots, f_n\) 及び \(g\) に対して、それぞれを計算するマシン \(M_1, \ldots, M_n, M\) が与えられているとする。
上の方法で得られるマシンは \(g \circ (f_1, \ldots f_n)\) を計算する。
注意点として、これを"続ける"の部分はマシンが先に与えられていれば単に順に操作を行うだけでよい。
これは後述する原始再帰関数の構成とは異なる。

### 原始再帰関数
原始再帰関数については次のような順序で呼ぶ。
マシンを \(M_0, M_1\) と用意する。
受け取るのは \((X, -, \mathbb{B}\overline{x}p-)\) のようになっているとする。

| やること | 結果（テープ） |
| --- | --- |
| 右側を \(x\) の値を下げながらコピーし、 \(x = 0\) になったら \(p\) のみをコピーする。| \((X, -, \mathbb{B}\overline{x-1}p-\mathbb{B}\overline{x-2}-...-\mathbb{B}p-p-)\) |
| 一番右側に行き、 \(M_0\) を呼ぶ。| \((X \# - \mathbb{B}\overline{x-1}p-\mathbb{B}\overline{x-2}-...-\mathbb{B}p , -, M_0(p)-)\) |
| （☆）現在の状況 | \((X \# - p_1 ... p_k, -, \mathbb{B} n -)\) |
| **もし** 左側が \(\#\) なら、 \(\#\) を除去し間を詰めて終了する。| \((X \# ,-, k-)\) から \((X, -, k-)\) |
| 一つ左へ行く | \((X, \# - p_1 ... p_{k-1}, - , p_k - \mathbb{B} n -)\) |
| 二つを入れ替えた後くっつける。 | \((X, \# - p_1 ... p_{k-1}, - , \mathbb{B} n p_k -)\) |
| \(M_1\) を呼ぶ | \((X, \# - p_1 ... p_{k-1}, - , M(n p_k))\) |
| （☆）の部分に戻る。 |  |

合成関数と同じように、これも対応する原始関数を計算するマシンを構成している。
どんな大きさの引数が与えられるかマシンを得た段階ではわからないことから、
このマシンの構成にはループが含まれている。
ただし、初めに左側に \(\#\) をつけたことと、右側から左に順々に畳みこんでいくことからこのループは（与えられたマシンが停止する場合には）必ず停止する。

### \(\mu\) 再帰関数
\(\mu\) 再帰関数については次のような順序で呼ぶ。
マシンを \(M\) と用意する。
受けとるのは \((X, -, p-)\) となっているとする。

| やること | 結果（テープ） |
| --- | --- |
| \((X, -, p-\overline{(0)}-)\) と変形する。| \((X, -, p-\overline{(0)}-)\) |
| （☆）現在の状況 \((X, -, p-\overline{(x)}-)\) | \((X, -, p-\overline{(x)}-)\) |
| \((X - p- \overline{(x)}, -, \overline{(x, p)} -)\) と変形する。 | \((X - p- \overline{(x)}, -, \overline{(x, p)} -)\) |
| \(M\) を呼ぶ | \((X - p- \overline{(x)}, -, M(\overline{(x, p)}) -)\) |
| もし右側が \(0\) なら次のように変形して終了する | \((X -p- \overline{(x)}, -,\mathbb{B}-)\) から \((X, -, \overline{(x)} -)\) |
| （以降は \(0\) でない場合）：右側を消して左側に行く | \((X - p ,-, \overline{(x)} -)\) |
| 右に \(1\) を足したら左側に行く | \((X, -, p-\overline{(x+1)}-)\) |
| （☆）に戻る | |

これも対応する \(\mu\) 再帰関数を計算している。
万が一与えられたマシンが与えられた入力に対して \(0\) を出力するような \(x\) を持たない場合、
このマシンは止まらない。

### 例

上三つの関数に対して、具体的に構成したチューリングマシンを以下においておく。
例は上から

- \(\text{succ} \circ (\text{proj}^3_0)\)
- 足し算
- 掛け算を用いた \(m \in \Nat \mapsto 0 \in \Nat\)

ないです。

